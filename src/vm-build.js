var GPDATA = {
 "fileTemplate": {
  "src_usevm.js": {
   "data": "(function () {\n//ignore these variables, for the module stuff.\n    var module = {exports:null,filename:JSON.stringify(name)};\n    var require = function (a) {return gp_require(a,\"./src/usevm.js\");};\n    var var__gvbvdxx_pack_filedata = null; //prevent overwrite\n    var cur_file = \"./src/usevm.js\";\n    module.exports = true;\n    return module;\n})();",
   "name": "./src/usevm.js",
   "dirname": "src_usevm.js",
   "realdir": "src_usevm.js",
   "realdirNoReplacer": "src\\usevm.js",
   "uncompileddata": "module.exports = true;"
  },
  "src_index.js": {
   "data": "(function () {\n//ignore these variables, for the module stuff.\n    var module = {exports:null,filename:JSON.stringify(name)};\n    var require = function (a) {return gp_require(a,\"./src/index.js\");};\n    var var__gvbvdxx_pack_filedata = null; //prevent overwrite\n    var cur_file = \"./src/index.js\";\n    /*\r\n    Uncomment this if you want cloud variables\r\n    \r\n    \r\n    window.cloudsetup = {\r\n        ws:\"ws://localhost:4726\", //websocket url\r\n        id:12345 //connection id, to separate cloud messages from others\r\n    };\r\n    */\r\n    \r\n    window.useBlocklyBlocks = false; //change this to true to have more blocks (from blockly)\r\n    window.useConfirmDialog = true; //asks the user if they want to save their changes (if true)\r\n    \r\n    //this here loads everything.\r\n    var usevm = require(\"src/usevm.js\");\r\n    var ggm2path = require(\"src/paths.js\");\r\n    if (usevm) {\r\n        function doScriptAdd(s) {\r\n            return require(\"src/\" + ggm2path + \"/\" + s);\r\n        }\r\n        doScriptAdd(\"ggm-vm/index.js\");\r\n        doScriptAdd(\"ggm-vm/renderer.js\");\r\n        doScriptAdd(\"ggm-vm/audio.js\");\r\n        doScriptAdd(\"ggm-vm/better-audio-ctx.js\");\r\n    } else {\r\n        require(\"src/\"+ggm2path+\"/ggm-gui/main.js\");\r\n    }\n    return module;\n})();",
   "name": "./src/index.js",
   "dirname": "src_index.js",
   "realdir": "src_index.js",
   "realdirNoReplacer": "src\\index.js",
   "uncompileddata": "/*\r\nUncomment this if you want cloud variables\r\n\r\n\r\nwindow.cloudsetup = {\r\n\tws:\"ws://localhost:4726\", //websocket url\r\n\tid:12345 //connection id, to separate cloud messages from others\r\n};\r\n*/\r\n\r\nwindow.useBlocklyBlocks = false; //change this to true to have more blocks (from blockly)\r\nwindow.useConfirmDialog = true; //asks the user if they want to save their changes (if true)\r\n\r\n//this here loads everything.\r\nvar usevm = require(\"src/usevm.js\");\r\nvar ggm2path = require(\"src/paths.js\");\r\nif (usevm) {\r\n\tfunction doScriptAdd(s) {\r\n\t\treturn require(\"src/\" + ggm2path + \"/\" + s);\r\n\t}\r\n\tdoScriptAdd(\"ggm-vm/index.js\");\r\n\tdoScriptAdd(\"ggm-vm/renderer.js\");\r\n\tdoScriptAdd(\"ggm-vm/audio.js\");\r\n\tdoScriptAdd(\"ggm-vm/better-audio-ctx.js\");\r\n} else {\r\n\trequire(\"src/\"+ggm2path+\"/ggm-gui/main.js\");\r\n}"
  },
  "src_paths.js": {
   "data": "(function () {\n//ignore these variables, for the module stuff.\n    var module = {exports:null,filename:JSON.stringify(name)};\n    var require = function (a) {return gp_require(a,\"./src/paths.js\");};\n    var var__gvbvdxx_pack_filedata = null; //prevent overwrite\n    var cur_file = \"./src/paths.js\";\n    //path for ggm2\r\n    module.exports = \"ggm2\";\r\n    \n    return module;\n})();",
   "name": "./src/paths.js",
   "dirname": "src_paths.js",
   "realdir": "src_paths.js",
   "realdirNoReplacer": "src\\paths.js",
   "uncompileddata": "//path for ggm2\r\nmodule.exports = \"ggm2\";\r\n"
  },
  "src_ggm2_ggm-vm_audio.js": {
   "data": "(function () {\n//ignore these variables, for the module stuff.\n    var module = {exports:null,filename:JSON.stringify(name)};\n    var require = function (a) {return gp_require(a,\"src\\\\ggm2\\\\ggm-vm\\\\audio.js\");};\n    var var__gvbvdxx_pack_filedata = null; //prevent overwrite\n    var cur_file = \"src\\\\ggm2\\\\ggm-vm\\\\audio.js\";\n    window.audioEngine = {\r\n        addToPreload: async function (url) {\r\n            var request = await fetch(url);\r\n            var data = await request.arrayBuffer();\r\n            window.audioEngine.audPreload[url] = window.audioEngine.copyArrayBuffer(window.audioEngine.audPreload[url]);\r\n        },\r\n        audPreload: {},\r\n        copyArrayBuffer: function (src)  {\r\n            var dst = new ArrayBuffer(src.byteLength);\r\n            new Uint8Array(dst).set(new Uint8Array(src));\r\n            return dst;\r\n        },\r\n        sfx:{\r\n            audio:null,\r\n            audioelements:[],\r\n            play:async function (a) {\r\n                /**\r\n                Bug Fix!\r\n                \r\n                fixed the audio bug when playing mutiple sounds, including long ones,\r\n                making it imposible to stop in desktop app.\r\n                \r\n                */\r\n                window.audioEngine.audioRunning = true;\r\n                if (!(window.audioEngine.audPreload[a])) {\r\n                    var request = await fetch(a);\r\n                    var data = await request.arrayBuffer();\r\n                    window.audioEngine.audPreload[a] = window.audioEngine.copyArrayBuffer(data);\r\n                } else {\r\n                    var data = window.audioEngine.copyArrayBuffer(window.audioEngine.audPreload[a]);\r\n                }\r\n                var audioBuffer = await window.audioEngine.decodeAudioDataAsync(data);\r\n                var source = window.audioEngine.context.createBufferSource();\r\n                if (window.audioEngine.audioRunning) {\r\n                    source.buffer = audioBuffer;\r\n                    this.source = source;\r\n                    \r\n                    source.connect(window.audioEngine.context.destination);\r\n                    source.loop = false;\r\n                    source.start();\r\n                    window.audioEngine.sources.push(source);\r\n                    source.onended = function () {\r\n                        var dat = [];\r\n                        for (var obj of window.audioEngine.sources) {\r\n                            if (!(obj == source)) {\r\n                                dat.push(obj);\r\n                            }\r\n                        }\r\n                        window.audioEngine.sources = dat;\r\n                    };\r\n                }\r\n    /*             //bug pach starts here\r\n                this.audio.onended = function () {\r\n                    delete audioEngine.sfx.audioelements.indexOf(this.audio);\r\n                    var allSfx = [];\r\n                    for (var i in audioEngine.sfx.audioelements) {\r\n                        if (audioEngine.sfx.audioelements) {\r\n                            allSfx.push(audioEngine.sfx.audioelements[i]);\r\n                        }\r\n                    }\r\n                    audioEngine.sfx.audioelements = allSfx;\r\n                }; */\r\n            }\r\n        },\r\n        decodeAudioDataAsync: (data) => {\r\n            return new Promise((resolve,reject) => {\r\n                window.audioEngine.context.decodeAudioData(data,resolve,reject);\r\n            })\r\n        },\r\n        sources: [\r\n        \r\n        ],\r\n        audioRunning:false,\r\n        bgm:{\r\n            audio:{src:\"\"},\r\n            isPlaying:false,\r\n            running:false,\r\n            stopRunningSource: () => {\r\n                if (this.source) {\r\n                    try{\r\n                        this.source.stop();\r\n                    }catch(e){}\r\n                }\r\n            },\r\n            play:async function () {\r\n                try{\r\n                    this.running = true;\r\n                    this.isPlaying = false;\r\n                    this.stopRunningSource();\r\n                    var source = window.audioEngine.context.createBufferSource();\r\n                    window.audioEngine.sources.push(source);\r\n                    window.audioEngine.audioRunning = true;\r\n                    if (!(window.audioEngine.audPreload[this.audio.src])) {\r\n                        this.stopRunningSource();\r\n                        var request = await fetch(this.audio.src);\r\n                        this.stopRunningSource();\r\n                        this.isPlaying = false;\r\n                        this.stopRunningSource();\r\n                        var data = await request.arrayBuffer();\r\n                        this.stopRunningSource();\r\n                        this.isPlaying = false;\r\n                        window.audioEngine.audPreload[this.audio.src] = window.audioEngine.copyArrayBuffer(data);\r\n                    } else {\r\n                        this.isPlaying = false;\r\n                        this.stopRunningSource();\r\n                        var data = window.audioEngine.copyArrayBuffer(window.audioEngine.audPreload[this.audio.src]);\r\n                        this.isPlaying = false;\r\n                        this.stopRunningSource();\r\n                    }\r\n                    this.isPlaying = false;\r\n                    this.stopRunningSource();\r\n                    var audioBuffer = await window.audioEngine.decodeAudioDataAsync(data);\r\n                    this.stopRunningSource();\r\n                    this.isPlaying = false;\r\n                    source.buffer = audioBuffer;\r\n                    this.isPlaying = false;\r\n                    source.connect(window.audioEngine.context.destination);\r\n                    source.loop = true;\r\n                    this.isPlaying = false;\r\n                    if (this.source) {\r\n                        try{\r\n                            this.source.stop();\r\n                        }catch(e){}\r\n                    }\r\n                    this.source = source;\r\n                    if (window.audioEngine.audioRunning) {\r\n                        if (!(this.isPlaying)) {\r\n                            this.isPlaying = true;\r\n                            source.start();\r\n                        }\r\n                    }\r\n                }catch(e){\r\n                    console.warn(\"[AudioEngine]:error ignored\" + e);\r\n                };\r\n            },\r\n            setSrc:function (a) {\r\n                this.audio.src = a;\r\n            }\r\n        },\r\n        audPreload:{\r\n            \r\n        },\r\n        stop:function () {\r\n            try{\r\n            if (this.sfx.audio) {\r\n                this.sfx.audio.pause();\r\n                this.sfx.audio = null;\r\n            }\r\n            this.bgm.running = false;\r\n            this.bgm.isPlaying = false;\r\n            this.audioRunning = false;\r\n            for (var source of this.sources) {\r\n                try{\r\n                    source.stop()\r\n                }catch(e){}\r\n            }\r\n            this.sources = [];\r\n            }catch(e){\r\n                console.warn(\"[AudioEngine]:error ignored\" + e);\r\n            };\r\n            vm.betterAudio.stopAllAudios();\r\n        },\r\n        tickAudio:function () {\r\n            //console.log(this.bgm.isPlaying);\r\n            if (window.audioEngine.bgm.isPlaying) {\r\n                //if (!(window.audioEngine.bgm.running)) {\r\n                //    window.audioEngine.bgm.play();\r\n                //}\r\n            } else {\r\n                try{\r\n                    window.audioEngine.bgm.running = false;\r\n                    window.audioEngine.bgm.source.stop();\r\n                }catch(e){}\r\n            }\r\n        }\r\n    }\r\n    window.audioEngine.bgm.audio.loop = true;\r\n    setInterval(window.audioEngine.tickAudio,1);\r\n    window.audioEngine.context = new AudioContext();\r\n    setInterval(() => {\r\n        if (!(window.audioEngine.context.state == \"running\")) {\r\n            window.audioEngine.context = new AudioContext\r\n        }\r\n    },10);\r\n    /*\r\n    the idea was to use context, but scrapped, because of more load lag and how mutch time it takes\r\n    window.audioEngine = {\r\n        context:new AudioContext(),\r\n        source: null,\r\n        sources:[],\r\n        apiGetAudio: async (audioBufferData,callback) => {\r\n          const context = window.audioEngine.context;\r\n            function copy(src)  {\r\n                var dst = new ArrayBuffer(src.byteLength);\r\n                new Uint8Array(dst).set(new Uint8Array(src));\r\n                return dst;\r\n            }\r\n          context.decodeAudioData(copy(audioBufferData),function (audioBuffer) {\r\n            window.audioEngine.source = context.createBufferSource();\r\n            var source = window.audioEngine.source\r\n            source.buffer = audioBuffer;\r\n            source.connect(context.destination);\r\n            source.start();\r\n            window.audioEngine.sources.push(source);\r\n            source.running = true;\r\n            source.onended = function () {\r\n                if (callback) {\r\n                    delete window.audioEngine.sources.indexOf(source);\r\n                    var sources = [];\r\n                    for (var i in window.audioEngine.sources) {\r\n                        if (window.audioEngine.sources[i]){\r\n                            sources.push(window.audioEngine.sources[i]);\r\n                        }\r\n                    }\r\n                    window.audioEngine.sources = sources;\r\n                    callback(source);\r\n                }\r\n            };\r\n          });\r\n        },\r\n        sfx:{\r\n            audio:null,\r\n            play:function (a) {\r\n                fetch(a).then((a) => {a.arrayBuffer().then((data) => {\r\n                    window.audioEngine.apiGetAudio(data);\r\n                })});\r\n            }\r\n        },\r\n        bgm:{\r\n            audio:\"\",\r\n            isPlaying:false,\r\n            play:function () {\r\n                console.log(\"loading audio data\")\r\n                fetch(window.audioEngine.bgm.audio).then((data1) => {data1.arrayBuffer().then((data) => {\r\n                    console.log(\"playing audio.\");\r\n                    window.audioEngine.apiGetAudio(data,function (source) {\r\n                        if (source.running) {\r\n                            window.audioEngine.bgm.play();\r\n                        }\r\n                    });\r\n                })});\r\n            },\r\n            pause:function () {\r\n                for (var i in window.audioEngine.sources) {\r\n                    try{\r\n                        window.audioEngine.sources[i].stop();\r\n                        window.audioEngine.sources[i].running = false;\r\n                    }catch(e){console.warn(`[AudioEngine]:Failed to stop audio context source: ${e}`);}\r\n                }\r\n            },\r\n            setSrc:function (a) {\r\n                window.audioEngine.bgm.audio = a;\r\n            }\r\n        },\r\n        stop:function () {\r\n            try{\r\n            this.bgm.isPlaying = false;\r\n            }catch(e){\r\n                console.warn(\"[AudioEngine]:error ignored\" + e);\r\n            };\r\n        },\r\n        tickAudio:function () {\r\n            if (window.audioEngine.bgm.isPlaying == true) {\r\n                window.audioEngine.bgm.isPlaying = false;\r\n                window.audioEngine.bgm.play();\r\n            } else {\r\n                if (window.audioEngine.bgm.isPlaying == false) {\r\n                    window.audioEngine.bgm.isPlaying = null;\r\n                    window.audioEngine.bgm.pause();\r\n                } else {\r\n                    window.audioEngine.bgm.isPlaying = null;\r\n                }\r\n            }\r\n            if (!(audioEngine.context.state == \"running\")) {\r\n                audioEngine.context = new AudioContext();\r\n            }\r\n        },\r\n        active:false\r\n    }\r\n    window.audioEngine.bgm.audio.loop = true;\r\n    setInterval(window.audioEngine.tickAudio,1);*/\n    return module;\n})();",
   "name": "src\\ggm2\\ggm-vm\\audio.js",
   "dirname": "src_ggm2_ggm-vm_audio.js",
   "realdir": "src_ggm2_ggm-vm_audio.js",
   "realdirNoReplacer": "src\\ggm2\\ggm-vm\\audio.js",
   "uncompileddata": "window.audioEngine = {\r\n\taddToPreload: async function (url) {\r\n\t\tvar request = await fetch(url);\r\n\t\tvar data = await request.arrayBuffer();\r\n\t\twindow.audioEngine.audPreload[url] = window.audioEngine.copyArrayBuffer(window.audioEngine.audPreload[url]);\r\n\t},\r\n\taudPreload: {},\r\n\tcopyArrayBuffer: function (src)  {\r\n\t\tvar dst = new ArrayBuffer(src.byteLength);\r\n\t\tnew Uint8Array(dst).set(new Uint8Array(src));\r\n\t\treturn dst;\r\n\t},\r\n\tsfx:{\r\n\t\taudio:null,\r\n\t\taudioelements:[],\r\n\t\tplay:async function (a) {\r\n\t\t\t/**\r\n\t\t\tBug Fix!\r\n\t\t\t\r\n\t\t\tfixed the audio bug when playing mutiple sounds, including long ones,\r\n\t\t\tmaking it imposible to stop in desktop app.\r\n\t\t\t\r\n\t\t\t*/\r\n\t\t\twindow.audioEngine.audioRunning = true;\r\n\t\t\tif (!(window.audioEngine.audPreload[a])) {\r\n\t\t\t\tvar request = await fetch(a);\r\n\t\t\t\tvar data = await request.arrayBuffer();\r\n\t\t\t\twindow.audioEngine.audPreload[a] = window.audioEngine.copyArrayBuffer(data);\r\n\t\t\t} else {\r\n\t\t\t\tvar data = window.audioEngine.copyArrayBuffer(window.audioEngine.audPreload[a]);\r\n\t\t\t}\r\n\t\t\tvar audioBuffer = await window.audioEngine.decodeAudioDataAsync(data);\r\n\t\t\tvar source = window.audioEngine.context.createBufferSource();\r\n\t\t\tif (window.audioEngine.audioRunning) {\r\n\t\t\t\tsource.buffer = audioBuffer;\r\n\t\t\t\tthis.source = source;\r\n\t\t\t\t\r\n\t\t\t\tsource.connect(window.audioEngine.context.destination);\r\n\t\t\t\tsource.loop = false;\r\n\t\t\t\tsource.start();\r\n\t\t\t\twindow.audioEngine.sources.push(source);\r\n\t\t\t\tsource.onended = function () {\r\n\t\t\t\t\tvar dat = [];\r\n\t\t\t\t\tfor (var obj of window.audioEngine.sources) {\r\n\t\t\t\t\t\tif (!(obj == source)) {\r\n\t\t\t\t\t\t\tdat.push(obj);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\twindow.audioEngine.sources = dat;\r\n\t\t\t\t};\r\n\t\t\t}\r\n/* \t\t\t//bug pach starts here\r\n\t\t\tthis.audio.onended = function () {\r\n\t\t\t\tdelete audioEngine.sfx.audioelements.indexOf(this.audio);\r\n\t\t\t\tvar allSfx = [];\r\n\t\t\t\tfor (var i in audioEngine.sfx.audioelements) {\r\n\t\t\t\t\tif (audioEngine.sfx.audioelements) {\r\n\t\t\t\t\t\tallSfx.push(audioEngine.sfx.audioelements[i]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\taudioEngine.sfx.audioelements = allSfx;\r\n\t\t\t}; */\r\n\t\t}\r\n\t},\r\n\tdecodeAudioDataAsync: (data) => {\r\n\t\treturn new Promise((resolve,reject) => {\r\n\t\t\twindow.audioEngine.context.decodeAudioData(data,resolve,reject);\r\n\t\t})\r\n\t},\r\n\tsources: [\r\n\t\r\n\t],\r\n\taudioRunning:false,\r\n\tbgm:{\r\n\t\taudio:{src:\"\"},\r\n\t\tisPlaying:false,\r\n\t\trunning:false,\r\n\t\tstopRunningSource: () => {\r\n\t\t\tif (this.source) {\r\n\t\t\t\ttry{\r\n\t\t\t\t\tthis.source.stop();\r\n\t\t\t\t}catch(e){}\r\n\t\t\t}\r\n\t\t},\r\n\t\tplay:async function () {\r\n\t\t\ttry{\r\n\t\t\t\tthis.running = true;\r\n\t\t\t\tthis.isPlaying = false;\r\n\t\t\t\tthis.stopRunningSource();\r\n\t\t\t\tvar source = window.audioEngine.context.createBufferSource();\r\n\t\t\t\twindow.audioEngine.sources.push(source);\r\n\t\t\t\twindow.audioEngine.audioRunning = true;\r\n\t\t\t\tif (!(window.audioEngine.audPreload[this.audio.src])) {\r\n\t\t\t\t\tthis.stopRunningSource();\r\n\t\t\t\t\tvar request = await fetch(this.audio.src);\r\n\t\t\t\t\tthis.stopRunningSource();\r\n\t\t\t\t\tthis.isPlaying = false;\r\n\t\t\t\t\tthis.stopRunningSource();\r\n\t\t\t\t\tvar data = await request.arrayBuffer();\r\n\t\t\t\t\tthis.stopRunningSource();\r\n\t\t\t\t\tthis.isPlaying = false;\r\n\t\t\t\t\twindow.audioEngine.audPreload[this.audio.src] = window.audioEngine.copyArrayBuffer(data);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.isPlaying = false;\r\n\t\t\t\t\tthis.stopRunningSource();\r\n\t\t\t\t\tvar data = window.audioEngine.copyArrayBuffer(window.audioEngine.audPreload[this.audio.src]);\r\n\t\t\t\t\tthis.isPlaying = false;\r\n\t\t\t\t\tthis.stopRunningSource();\r\n\t\t\t\t}\r\n\t\t\t\tthis.isPlaying = false;\r\n\t\t\t\tthis.stopRunningSource();\r\n\t\t\t\tvar audioBuffer = await window.audioEngine.decodeAudioDataAsync(data);\r\n\t\t\t\tthis.stopRunningSource();\r\n\t\t\t\tthis.isPlaying = false;\r\n\t\t\t\tsource.buffer = audioBuffer;\r\n\t\t\t\tthis.isPlaying = false;\r\n\t\t\t\tsource.connect(window.audioEngine.context.destination);\r\n\t\t\t\tsource.loop = true;\r\n\t\t\t\tthis.isPlaying = false;\r\n\t\t\t\tif (this.source) {\r\n\t\t\t\t\ttry{\r\n\t\t\t\t\t\tthis.source.stop();\r\n\t\t\t\t\t}catch(e){}\r\n\t\t\t\t}\r\n\t\t\t\tthis.source = source;\r\n\t\t\t\tif (window.audioEngine.audioRunning) {\r\n\t\t\t\t\tif (!(this.isPlaying)) {\r\n\t\t\t\t\t\tthis.isPlaying = true;\r\n\t\t\t\t\t\tsource.start();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}catch(e){\r\n\t\t\t\tconsole.warn(\"[AudioEngine]:error ignored\" + e);\r\n\t\t\t};\r\n\t\t},\r\n\t\tsetSrc:function (a) {\r\n\t\t\tthis.audio.src = a;\r\n\t\t}\r\n\t},\r\n\taudPreload:{\r\n\t\t\r\n\t},\r\n\tstop:function () {\r\n\t\ttry{\r\n\t\tif (this.sfx.audio) {\r\n\t\t\tthis.sfx.audio.pause();\r\n\t\t\tthis.sfx.audio = null;\r\n\t\t}\r\n\t\tthis.bgm.running = false;\r\n\t\tthis.bgm.isPlaying = false;\r\n\t\tthis.audioRunning = false;\r\n\t\tfor (var source of this.sources) {\r\n\t\t\ttry{\r\n\t\t\t\tsource.stop()\r\n\t\t\t}catch(e){}\r\n\t\t}\r\n\t\tthis.sources = [];\r\n\t\t}catch(e){\r\n\t\t\tconsole.warn(\"[AudioEngine]:error ignored\" + e);\r\n\t\t};\r\n\t\tvm.betterAudio.stopAllAudios();\r\n\t},\r\n\ttickAudio:function () {\r\n\t\t//console.log(this.bgm.isPlaying);\r\n\t\tif (window.audioEngine.bgm.isPlaying) {\r\n\t\t\t//if (!(window.audioEngine.bgm.running)) {\r\n\t\t\t//\twindow.audioEngine.bgm.play();\r\n\t\t\t//}\r\n\t\t} else {\r\n\t\t\ttry{\r\n\t\t\t\twindow.audioEngine.bgm.running = false;\r\n\t\t\t\twindow.audioEngine.bgm.source.stop();\r\n\t\t\t}catch(e){}\r\n\t\t}\r\n\t}\r\n}\r\nwindow.audioEngine.bgm.audio.loop = true;\r\nsetInterval(window.audioEngine.tickAudio,1);\r\nwindow.audioEngine.context = new AudioContext();\r\nsetInterval(() => {\r\n\tif (!(window.audioEngine.context.state == \"running\")) {\r\n\t\twindow.audioEngine.context = new AudioContext\r\n\t}\r\n},10);\r\n/*\r\nthe idea was to use context, but scrapped, because of more load lag and how mutch time it takes\r\nwindow.audioEngine = {\r\n\tcontext:new AudioContext(),\r\n\tsource: null,\r\n\tsources:[],\r\n\tapiGetAudio: async (audioBufferData,callback) => {\r\n\t  const context = window.audioEngine.context;\r\n\t\tfunction copy(src)  {\r\n\t\t\tvar dst = new ArrayBuffer(src.byteLength);\r\n\t\t\tnew Uint8Array(dst).set(new Uint8Array(src));\r\n\t\t\treturn dst;\r\n\t\t}\r\n\t  context.decodeAudioData(copy(audioBufferData),function (audioBuffer) {\r\n\t\twindow.audioEngine.source = context.createBufferSource();\r\n\t\tvar source = window.audioEngine.source\r\n\t\tsource.buffer = audioBuffer;\r\n\t\tsource.connect(context.destination);\r\n\t\tsource.start();\r\n\t\twindow.audioEngine.sources.push(source);\r\n\t\tsource.running = true;\r\n\t\tsource.onended = function () {\r\n\t\t\tif (callback) {\r\n\t\t\t\tdelete window.audioEngine.sources.indexOf(source);\r\n\t\t\t\tvar sources = [];\r\n\t\t\t\tfor (var i in window.audioEngine.sources) {\r\n\t\t\t\t\tif (window.audioEngine.sources[i]){\r\n\t\t\t\t\t\tsources.push(window.audioEngine.sources[i]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\twindow.audioEngine.sources = sources;\r\n\t\t\t\tcallback(source);\r\n\t\t\t}\r\n\t\t};\r\n\t  });\r\n\t},\r\n\tsfx:{\r\n\t\taudio:null,\r\n\t\tplay:function (a) {\r\n\t\t\tfetch(a).then((a) => {a.arrayBuffer().then((data) => {\r\n\t\t\t\twindow.audioEngine.apiGetAudio(data);\r\n\t\t\t})});\r\n\t\t}\r\n\t},\r\n\tbgm:{\r\n\t\taudio:\"\",\r\n\t\tisPlaying:false,\r\n\t\tplay:function () {\r\n\t\t\tconsole.log(\"loading audio data\")\r\n\t\t\tfetch(window.audioEngine.bgm.audio).then((data1) => {data1.arrayBuffer().then((data) => {\r\n\t\t\t\tconsole.log(\"playing audio.\");\r\n\t\t\t\twindow.audioEngine.apiGetAudio(data,function (source) {\r\n\t\t\t\t\tif (source.running) {\r\n\t\t\t\t\t\twindow.audioEngine.bgm.play();\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t})});\r\n\t\t},\r\n\t\tpause:function () {\r\n\t\t\tfor (var i in window.audioEngine.sources) {\r\n\t\t\t\ttry{\r\n\t\t\t\t\twindow.audioEngine.sources[i].stop();\r\n\t\t\t\t\twindow.audioEngine.sources[i].running = false;\r\n\t\t\t\t}catch(e){console.warn(`[AudioEngine]:Failed to stop audio context source: ${e}`);}\r\n\t\t\t}\r\n\t\t},\r\n\t\tsetSrc:function (a) {\r\n\t\t\twindow.audioEngine.bgm.audio = a;\r\n\t\t}\r\n\t},\r\n\tstop:function () {\r\n\t\ttry{\r\n\t\tthis.bgm.isPlaying = false;\r\n\t\t}catch(e){\r\n\t\t\tconsole.warn(\"[AudioEngine]:error ignored\" + e);\r\n\t\t};\r\n\t},\r\n\ttickAudio:function () {\r\n\t\tif (window.audioEngine.bgm.isPlaying == true) {\r\n\t\t\twindow.audioEngine.bgm.isPlaying = false;\r\n\t\t\twindow.audioEngine.bgm.play();\r\n\t\t} else {\r\n\t\t\tif (window.audioEngine.bgm.isPlaying == false) {\r\n\t\t\t\twindow.audioEngine.bgm.isPlaying = null;\r\n\t\t\t\twindow.audioEngine.bgm.pause();\r\n\t\t\t} else {\r\n\t\t\t\twindow.audioEngine.bgm.isPlaying = null;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (!(audioEngine.context.state == \"running\")) {\r\n\t\t\taudioEngine.context = new AudioContext();\r\n\t\t}\r\n\t},\r\n\tactive:false\r\n}\r\nwindow.audioEngine.bgm.audio.loop = true;\r\nsetInterval(window.audioEngine.tickAudio,1);*/"
  },
  "src_ggm2_ggm-vm_better-audio-ctx.js": {
   "data": "(function () {\n//ignore these variables, for the module stuff.\n    var module = {exports:null,filename:JSON.stringify(name)};\n    var require = function (a) {return gp_require(a,\"src\\\\ggm2\\\\ggm-vm\\\\better-audio-ctx.js\");};\n    var var__gvbvdxx_pack_filedata = null; //prevent overwrite\n    var cur_file = \"src\\\\ggm2\\\\ggm-vm\\\\better-audio-ctx.js\";\n    var audios = [];\r\n    function stopAllAudios() {\r\n        for (var a of audios) {\r\n            a.pause();\r\n            a.load = function () {};\r\n            a.data = null;\r\n            a.play = function () {};\r\n            a.pause = function () {};\r\n        }\r\n        audios = [];\r\n    }\r\n    var audioCTX = new AudioContext();\r\n    function decodeAsync(d) {\r\n        return new Promise((a) => {\r\n            try {\r\n                audioCTX.decodeAudioData(d, a);\r\n            } catch (e) {\r\n                a(null);\r\n            }\r\n        });\r\n    }\r\n    setInterval(() => {\r\n        if (!(audioCTX.state == \"running\")) {\r\n            audioCTX = new AudioContext();\r\n        }\r\n    }, 1);\r\n    var preload = {};\r\n    class AudioApiReplacement {\r\n        constructor(url) {\r\n    \r\n            audios.push(this);\r\n            this.dataurl = url;\r\n            this.data = null;\r\n            this.source = null;\r\n            this.playbackRate = 1;\r\n            this.looped = false;\r\n            this.setVolume(1);\r\n        }\r\n        async load() {\r\n            var a = await fetch(this.dataurl);\r\n            var b = await a.arrayBuffer();\r\n            var c = await decodeAsync(b);\r\n            this.data = c;\r\n        }\r\n        play() {\r\n            if (this.data) {\r\n                if (!this.source) {\r\n                    function loadSample(url) {\r\n                        return fetch(url).then((response) => response.arrayBuffer());\r\n                    }\r\n                    const source = audioCTX.createBufferSource();\r\n                    function copy(src) {\r\n                        var dst = new ArrayBuffer(src.byteLength);\r\n                        new Uint8Array(dst).set(new Uint8Array(src));\r\n                        return dst;\r\n                    }\r\n                    this.gainNode = audioCTX.createGain();\r\n                    function decodeAudioData(data, out) {\r\n                        try {\r\n                            out(window.DADF.getFileAudioBuffer(data, audioCTX));\r\n                        } catch (e) {\r\n                            window.alert(e);\r\n                        }\r\n                    }\r\n                    var t = this;\r\n                    function play(buffer) {\r\n                        source.buffer = buffer;\r\n                        source.playbackRate.value = t.playbackRate;\r\n                        source.connect(t.gainNode);\r\n                        t.gainNode.connect(audioCTX.destination);\r\n                        t.gainNode.gain.value = t.startVol;\r\n                        source.looped = t.looped;\r\n                        source.start(0);\r\n                        t.source = source;\r\n    \r\n                        var s = t;\r\n                        source.onended = function () {\r\n                            s.onended();\r\n                            s.source = null;\r\n                        };\r\n                    }\r\n                    function cloneAudioBuffer(fromAudioBuffer) {\r\n                        const audioBuffer = new AudioBuffer({\r\n                            length: fromAudioBuffer.length,\r\n                            numberOfChannels: fromAudioBuffer.numberOfChannels,\r\n                            sampleRate: fromAudioBuffer.sampleRate,\r\n                        });\r\n                        for (\r\n                            let channelI = 0;\r\n                            channelI < audioBuffer.numberOfChannels;\r\n                            ++channelI) {\r\n                            const samples = fromAudioBuffer.getChannelData(channelI);\r\n                            audioBuffer.copyToChannel(samples, channelI);\r\n                        }\r\n                        return audioBuffer;\r\n                    }\r\n                    try {\r\n                        play(cloneAudioBuffer(this.data));\r\n                    } catch (e) {\r\n                        window.alert(e);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        onended() {\r\n            /*Gets overwritten by the script.*/\r\n        }\r\n        pause() {\r\n            if (this.source) {\r\n                this.source.stop();\r\n                this.source = null;\r\n                this.gainNode = null;\r\n            }\r\n        }\r\n        remove() {\r\n            delete this;\r\n        }\r\n        setPlaybackRate(value) {\r\n            if (this.source) {\r\n                this.source.playbackRate.value = value;\r\n                this.playbackRate = value;\r\n            } else {\r\n                this.playbackRate = value;\r\n            }\r\n        }\r\n        getPlaybackRate(value) {\r\n            return this.playbackRate;\r\n        }\r\n        setVolume(value) {\r\n            if (this.source) {\r\n                //console.log(value);\r\n                this.gainNode.gain.value = value;\r\n            } else {\r\n                this.startVol = value;\r\n            }\r\n        }\r\n        getVolume() {\r\n            return this.gainNode.gain.value;\r\n        }\r\n    }\r\n    window.vm.betterAudio = {\r\n        c: AudioApiReplacement,\r\n        preload: preload,\r\n        decodeAsync: decodeAsync,\r\n        audios: audios,\r\n        stopAllAudios: stopAllAudios\r\n    };\r\n    \n    return module;\n})();",
   "name": "src\\ggm2\\ggm-vm\\better-audio-ctx.js",
   "dirname": "src_ggm2_ggm-vm_better-audio-ctx.js",
   "realdir": "src_ggm2_ggm-vm_better-audio-ctx.js",
   "realdirNoReplacer": "src\\ggm2\\ggm-vm\\better-audio-ctx.js",
   "uncompileddata": "var audios = [];\r\nfunction stopAllAudios() {\r\n    for (var a of audios) {\r\n        a.pause();\r\n        a.load = function () {};\r\n        a.data = null;\r\n        a.play = function () {};\r\n        a.pause = function () {};\r\n    }\r\n    audios = [];\r\n}\r\nvar audioCTX = new AudioContext();\r\nfunction decodeAsync(d) {\r\n    return new Promise((a) => {\r\n        try {\r\n            audioCTX.decodeAudioData(d, a);\r\n        } catch (e) {\r\n            a(null);\r\n        }\r\n    });\r\n}\r\nsetInterval(() => {\r\n    if (!(audioCTX.state == \"running\")) {\r\n        audioCTX = new AudioContext();\r\n    }\r\n}, 1);\r\nvar preload = {};\r\nclass AudioApiReplacement {\r\n    constructor(url) {\r\n\r\n        audios.push(this);\r\n        this.dataurl = url;\r\n        this.data = null;\r\n        this.source = null;\r\n        this.playbackRate = 1;\r\n        this.looped = false;\r\n        this.setVolume(1);\r\n    }\r\n    async load() {\r\n        var a = await fetch(this.dataurl);\r\n        var b = await a.arrayBuffer();\r\n        var c = await decodeAsync(b);\r\n        this.data = c;\r\n    }\r\n    play() {\r\n        if (this.data) {\r\n            if (!this.source) {\r\n                function loadSample(url) {\r\n                    return fetch(url).then((response) => response.arrayBuffer());\r\n                }\r\n                const source = audioCTX.createBufferSource();\r\n                function copy(src) {\r\n                    var dst = new ArrayBuffer(src.byteLength);\r\n                    new Uint8Array(dst).set(new Uint8Array(src));\r\n                    return dst;\r\n                }\r\n                this.gainNode = audioCTX.createGain();\r\n                function decodeAudioData(data, out) {\r\n                    try {\r\n                        out(window.DADF.getFileAudioBuffer(data, audioCTX));\r\n                    } catch (e) {\r\n                        window.alert(e);\r\n                    }\r\n                }\r\n                var t = this;\r\n                function play(buffer) {\r\n                    source.buffer = buffer;\r\n                    source.playbackRate.value = t.playbackRate;\r\n                    source.connect(t.gainNode);\r\n                    t.gainNode.connect(audioCTX.destination);\r\n                    t.gainNode.gain.value = t.startVol;\r\n                    source.looped = t.looped;\r\n                    source.start(0);\r\n                    t.source = source;\r\n\r\n                    var s = t;\r\n                    source.onended = function () {\r\n                        s.onended();\r\n                        s.source = null;\r\n                    };\r\n                }\r\n                function cloneAudioBuffer(fromAudioBuffer) {\r\n                    const audioBuffer = new AudioBuffer({\r\n                        length: fromAudioBuffer.length,\r\n                        numberOfChannels: fromAudioBuffer.numberOfChannels,\r\n                        sampleRate: fromAudioBuffer.sampleRate,\r\n                    });\r\n                    for (\r\n                        let channelI = 0;\r\n                        channelI < audioBuffer.numberOfChannels;\r\n                        ++channelI) {\r\n                        const samples = fromAudioBuffer.getChannelData(channelI);\r\n                        audioBuffer.copyToChannel(samples, channelI);\r\n                    }\r\n                    return audioBuffer;\r\n                }\r\n                try {\r\n                    play(cloneAudioBuffer(this.data));\r\n                } catch (e) {\r\n                    window.alert(e);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    onended() {\r\n        /*Gets overwritten by the script.*/\r\n    }\r\n    pause() {\r\n        if (this.source) {\r\n            this.source.stop();\r\n            this.source = null;\r\n            this.gainNode = null;\r\n        }\r\n    }\r\n    remove() {\r\n        delete this;\r\n    }\r\n    setPlaybackRate(value) {\r\n        if (this.source) {\r\n            this.source.playbackRate.value = value;\r\n            this.playbackRate = value;\r\n        } else {\r\n            this.playbackRate = value;\r\n        }\r\n    }\r\n    getPlaybackRate(value) {\r\n        return this.playbackRate;\r\n    }\r\n    setVolume(value) {\r\n        if (this.source) {\r\n            //console.log(value);\r\n            this.gainNode.gain.value = value;\r\n        } else {\r\n            this.startVol = value;\r\n        }\r\n    }\r\n    getVolume() {\r\n        return this.gainNode.gain.value;\r\n    }\r\n}\r\nwindow.vm.betterAudio = {\r\n    c: AudioApiReplacement,\r\n    preload: preload,\r\n    decodeAsync: decodeAsync,\r\n    audios: audios,\r\n    stopAllAudios: stopAllAudios\r\n};\r\n"
  },
  "src_ggm2_ggm-vm_classes_sprite.js": {
   "data": "(function () {\n//ignore these variables, for the module stuff.\n    var module = {exports:null,filename:JSON.stringify(name)};\n    var require = function (a) {return gp_require(a,\"src\\\\ggm2\\\\ggm-vm\\\\classes\\\\sprite.js\");};\n    var var__gvbvdxx_pack_filedata = null; //prevent overwrite\n    var cur_file = \"src\\\\ggm2\\\\ggm-vm\\\\classes\\\\sprite.js\";\n    var console = require(\"log\");\r\n    class GGM2Sprite {\r\n        constructor (id) {\r\n            //the sprites cordinates, just like scratch, cordinates are from the center.\r\n            this.x = 0;\r\n            this.y = 0;\r\n            //the rotation of the sprite, just like scratch, 90 is up right.\r\n            this.direction = 90;\r\n            //size of sprite, also helps center the sprite.\r\n            this.width = 32;\r\n            this.height = 32;\r\n            //the costume/skin of the sprite.\r\n            this.image = null;\r\n            //flip the sprite and stuff.\r\n            this.flip = \"none\";\r\n            //used for deletion.\r\n            this.id = id;\r\n            //the ghost effect of the sprite, the closer it is to 100 the more see-through it gets.\r\n            this.ghost = 0;\r\n            //every time it gets clicked, all the functions in this array get called.\r\n            this.clicked = [];\r\n            //local variables.\r\n            this.localvars = {};\r\n            //is a sprite.\r\n            this.isSprite = true;\r\n        }\r\n    }\r\n    module.exports = GGM2Sprite;\n    return module;\n})();",
   "name": "src\\ggm2\\ggm-vm\\classes\\sprite.js",
   "dirname": "src_ggm2_ggm-vm_classes_sprite.js",
   "realdir": "src_ggm2_ggm-vm_classes_sprite.js",
   "realdirNoReplacer": "src\\ggm2\\ggm-vm\\classes\\sprite.js",
   "uncompileddata": "var console = require(\"log\");\r\nclass GGM2Sprite {\r\n\tconstructor (id) {\r\n\t\t//the sprites cordinates, just like scratch, cordinates are from the center.\r\n\t\tthis.x = 0;\r\n\t\tthis.y = 0;\r\n\t\t//the rotation of the sprite, just like scratch, 90 is up right.\r\n\t\tthis.direction = 90;\r\n\t\t//size of sprite, also helps center the sprite.\r\n\t\tthis.width = 32;\r\n\t\tthis.height = 32;\r\n\t\t//the costume/skin of the sprite.\r\n\t\tthis.image = null;\r\n\t\t//flip the sprite and stuff.\r\n\t\tthis.flip = \"none\";\r\n\t\t//used for deletion.\r\n\t\tthis.id = id;\r\n\t\t//the ghost effect of the sprite, the closer it is to 100 the more see-through it gets.\r\n\t\tthis.ghost = 0;\r\n\t\t//every time it gets clicked, all the functions in this array get called.\r\n\t\tthis.clicked = [];\r\n\t\t//local variables.\r\n\t\tthis.localvars = {};\r\n\t\t//is a sprite.\r\n\t\tthis.isSprite = true;\r\n\t}\r\n}\r\nmodule.exports = GGM2Sprite;"
  },
  "src_ggm2_ggm-vm_index.js": {
   "data": "(function () {\n//ignore these variables, for the module stuff.\n    var module = {exports:null,filename:JSON.stringify(name)};\n    var require = function (a) {return gp_require(a,\"src\\\\ggm2\\\\ggm-vm\\\\index.js\");};\n    var var__gvbvdxx_pack_filedata = null; //prevent overwrite\n    var cur_file = \"src\\\\ggm2\\\\ggm-vm\\\\index.js\";\n    var console = require(\"log\");\r\n    var ggm2path = require(\"src/paths.js\");\r\n    var Sprite = require(\"src/\" + ggm2path + \"/ggm-vm/classes/sprite.js\");\r\n    window.vm = {\r\n        daysSince2000: function () {\r\n            const msPerDay = 24 * 60 * 60 * 1000;\r\n            const start = new Date(2000, 0, 1); // Months are 0-indexed.\r\n            const today = new Date();\r\n            const dstAdjust = today.getTimezoneOffset() - start.getTimezoneOffset();\r\n            let mSecsSinceStart = today.valueOf() - start.valueOf();\r\n            mSecsSinceStart += ((today.getTimezoneOffset() - dstAdjust) * 60 * 1000);\r\n            return mSecsSinceStart / msPerDay;\r\n        },\r\n        messageData: [],\r\n        idcounter: 0,\r\n        startTime: 0,\r\n        resetTimer: () => {\r\n            vm.startTime = vm.daysSince2000() * 86400;\r\n            vm.project.timer = 0;\r\n        },\r\n        control: {\r\n            start: async function (a) {\r\n                if (vm.audioEngine) {\r\n                    if (vm.renderer) {\r\n                        for (var m of vm.messageData) {\r\n                            vm.messages[m] = [];\r\n                        }\r\n                        vm.control.stop();\r\n                        vm.resetTimer();\r\n                        vm.control.running = true;\r\n                        vm.idcounter = 0;\r\n                        vm.project.monitors = [];\r\n                        window.vm.renderer.camghost = 0;\r\n                        window.vm.renderer.bg.src = \"\";\r\n                        try {\r\n                            eval(\"(async function () {\\ntry{\\n\" + vm.code + \"\\n} catch (e) {\\nvm.console.error(e);\\n}\\n})();\");\r\n                        } catch (e) {\r\n                            vm.console.error(\"Error in script:\" + e);\r\n                        }\r\n                    } else {\r\n                        throw Error(\"Renderer Must Be Attached\");\r\n                    }\r\n                } else {\r\n                    throw Error(\"AudioEngine Must Be Attached\");\r\n                }\r\n            },\r\n            stop: function () {\r\n                for (var i in vm.project.timeouts) {\r\n                    clearTimeout(vm.project.timeouts[i]);\r\n                }\r\n                vm.project.timeouts = [];\r\n                vm.idcounter = 0;\r\n                vm.control.running = false;\r\n                vm.project.sprites = [];\r\n                vm.project.events.tick = [];\r\n                vm.project.sprites = [];\r\n                vm.project.keysPressed = [];\r\n                vm.project.keyListeners = {};\r\n                vm.audioEngine.stop();\r\n                try {\r\n                    window.vm.onstop();\r\n                } catch (e) {\r\n                    console.error(e);\r\n                }\r\n            },\r\n            running: false\r\n        },\r\n        code: \"\",\r\n        renderer: null,\r\n        attachRenderer: function (a) {\r\n            vm.renderer = a;\r\n            vm.renderer.start();\r\n            return a;\r\n        },\r\n        attachAudioEngine: function (a) {\r\n            vm.audioEngine = a;\r\n            return a;\r\n        },\r\n        setCompiadiblityMode: function (a) {\r\n            this.compiadiblityMode = a;\r\n        },\r\n        compiadiblityMode: false,\r\n        messages: {},\r\n        project: {\r\n            keyListeners: {},\r\n            mouseDown: false,\r\n            mouseX: 0,\r\n            mouseY: 0,\r\n            keysPressed: [],\r\n            sprites: [],\r\n            events: {\r\n                tick: []\r\n            },\r\n            monitors: [],\r\n            resources: [],\r\n            timer: 0,\r\n            timeouts: [],\r\n            block: {\r\n                convertURLToText: function (url) {\r\n                    try {\r\n                        return atob(url.split(\",\").pop());\r\n                    } catch (e) {\r\n                        vm.console.error(\"Error in script:\" + e);\r\n                    }\r\n                },\r\n                cloudVarSet: function (name, value) {\r\n                    try {\r\n                        if (vm.cloudAPI) {\r\n                            vm.cloudAPI.updateVariable(name, value);\r\n                        }\r\n                    } catch (e) {\r\n                        vm.console.error(\"Error in script:\" + e);\r\n                    }\r\n                },\r\n                cloudVarGet: function (name) {\r\n                    try {\r\n                        if (vm.cloudAPI) {\r\n                            var realValue = vm.cloudAPI.getVariable(name);\r\n                            //so users can understand the blocks easier\r\n                            if (Number(realValue)) {\r\n                                realValue = Number(realValue);\r\n                            }\r\n                            return realValue;\r\n                        }\r\n                    } catch (e) {\r\n                        vm.console.error(\"Error in script:\" + e);\r\n                    }\r\n                },\r\n                tickAsync: function () {\r\n                    return new Promise((a) => {\r\n                        setTimeout(a, 1);\r\n                    })\r\n                },\r\n                saveFileFromText: function (name,type,contents) {\r\n                    var myFile = new Blob([contents], {\r\n                        type: type\r\n                    });\r\n                    \r\n                    var objectURL = window.URL || window.webkitURL;\r\n                    var a = document.createElement(\"a\");\r\n    \r\n                    a.href = objectURL.createObjectURL(myFile);\r\n                    a.download = name;\r\n                    a.click();\r\n                },\r\n                loadFileAsText: function (extensions,callback) {\r\n                    var objectURL = window.URL || window.webkitURL;\r\n                    var input = document.createElement(\"input\");\r\n                    input.type = \"file\";\r\n                    input.accept = extensions;\r\n                    input.click();\r\n                    \r\n                    input.onchange = function () {\r\n                        if (input.files.length > 0) {\r\n                            var file = input.files[0];\r\n                            var reader = new FileReader();\r\n                            reader.onload = function () {\r\n                                callback(reader.result);\r\n                                input.remove();\r\n                            };\r\n                            reader.readAsText(file);\r\n                        }\r\n                    };\r\n                },\r\n                waitAsync: function (s) {\r\n                    return new Promise((a) => {\r\n                        vm.project.timeouts.push(setTimeout(a, s * 1000));\r\n                    })\r\n                },\r\n                moveSteps: function (sprite, steps) {\r\n                    try {\r\n                        var realsteps = steps;\r\n                        var realdir = 90 - sprite.direction;\r\n                        var xBy = Math.cos(realdir * (Math.PI / 180)) * realsteps;\r\n                        var yBy = Math.sin(realdir * (Math.PI / 180)) * realsteps;\r\n                        var realxby = xBy + xBy;\r\n                        sprite.x = sprite.x + realxby;\r\n                        sprite.y = sprite.y + (yBy + yBy);\r\n                    } catch (e) {\r\n                        vm.console.error(\"Error in script:\" + e);\r\n                    }\r\n                },\r\n                deleteList: function (array, number) {\r\n                    try {\r\n                        delete array[number];\r\n                        var index = 0;\r\n                        var genaratedArray = [];\r\n                        while (array.length > index) {\r\n                            if (!(array[index] == undefined)) {\r\n                                genaratedArray.push(array[index]);\r\n                            }\r\n                            index += 1;\r\n                        }\r\n                        return genaratedArray;\r\n                    } catch (e) {\r\n                        vm.console.error(\"Error in script:\" + e);\r\n                    }\r\n                },\r\n                makeSprite: function () {\r\n                    try {\r\n                        vm.idcounter += 1;\r\n                        var realID = vm.project.sprites.length-1;\r\n                        var spr = new Sprite(realID);\r\n                        this.showSprite(spr);\r\n                        return spr;\r\n                        try {\r\n                            window.vm.onspritecreate(spr);\r\n                        } catch (e) {\r\n                            console.error(e);\r\n                        }\r\n                    } catch (e) {}\r\n    \r\n                },\r\n                makeMonitor: function () {\r\n                    try {\r\n                        var monitor = {\r\n                            x: 0,\r\n                            y: 0,\r\n                            value: 0,\r\n                            name: \"monitor\",\r\n                            visible: true,\r\n                            clicked: []\r\n                        };\r\n                        window.vm.project.monitors.push(monitor);\r\n                        return monitor;\r\n                    } catch (e) {\r\n                        vm.console.error(\"Error in script:\" + e);\r\n                    }\r\n                },\r\n                showSprite: function (spr) {\r\n                    try {\r\n                        this.hideSprite(spr); //ensure there is only one sprite when showing again.\r\n                        vm.project.sprites.push(spr);\r\n                        var counter = 0;\r\n                        for (var spr2 of vm.project.sprites) {\r\n                            spr2.id = counter;\r\n                            counter += 1;\r\n                        }\r\n                    } catch (e) {\r\n                        vm.console.error(\"Error in script:\" + e);\r\n                    }\r\n                },\r\n                hideSprite: function (spr) {\r\n                    try {\r\n                        var i = vm.project.sprites.indexOf(spr);\r\n                        if (i > -1) {\r\n                            vm.project.sprites.splice(i, 1); // 2nd parameter means remove one item only\r\n                        }\r\n                        \r\n                        var counter = 0;\r\n                        for (var spr2 of vm.project.sprites) {\r\n                            spr2.id = counter;\r\n                            counter += 1;\r\n                        }\r\n                    } catch (e) {}\r\n                },\r\n                cos: function (number) {\r\n                    try {\r\n                        return Math.cos((number) * (Math.PI / 180));\r\n                    } catch (e) {\r\n                        vm.console.error(e);\r\n                    }\r\n                },\r\n                sin: function (number) {\r\n                    try {\r\n                        return Math.sin((number) * (Math.PI / 180));\r\n                    } catch (e) {\r\n                        vm.console.error(e);\r\n                    }\r\n                },\r\n                getMoseData: function () {\r\n                    try {\r\n                        return {\r\n                            x: vm.project.mouseX,\r\n                            y: vm.project.mouseY,\r\n                            down: vm.project.mouseDown\r\n                        };\r\n                    } catch (e) {}\r\n                },\r\n                dataToImg: function (dataURI) {\r\n                    try {\r\n                        var img = document.createElement(\"img\");\r\n                        img.src = dataURI;\r\n                        img.setAttribute(\"style\", \"image-rendering: pixelated;\");\r\n                        return img;\r\n                    } catch (e) {}\r\n                },\r\n                random: function (a, b) {\r\n                    if (a > b) {\r\n                        // Swap a and b to ensure a is smaller.\r\n                        var c = a;\r\n                        a = b;\r\n                        b = c;\r\n                    }\r\n                    return Math.floor(Math.random() * (b - a + 1) + a);\r\n                },\r\n                isTouching: function (sprite1, sprite2, mode) {\r\n                    /*if (sp1.x > sp2.x) {\r\n                    var devideNumX = -2;\r\n                    } else {\r\n                    var devideNumX = 2;\r\n                    }\r\n                    sp1.x -= sp1.width/devideNumX;\r\n                    var res = (\r\n                    sp1.x < sp2.x + (sp2.width/1) &&\r\n                    sp1.x + (sp1.width/1) > sp2.x &&\r\n                    sp1.y < sp2.y + sp2.height &&\r\n                    sp1.height + sp1.y > sp2.y\r\n                    );\r\n                    sp1.x += sp1.width/devideNumX;\r\n                    return res;*/\r\n                    try {\r\n                        return vm.___CHECKCOLLIDE(sprite1, sprite2);\r\n                    } catch (e) {\r\n                        vm.console.error(\"Error in script:\" + e);\r\n                    }\r\n                },\r\n                getKeyPressed: function (keyname) {\r\n                    try {\r\n                        if (vm.project.keysPressed[keyname]) {\r\n                            return true;\r\n                        } else {\r\n                            return false;\r\n                        }\r\n                    } catch (e) {}\r\n                },\r\n                wait: function (secs, callback) {\r\n                    try {\r\n                        /**Update For V1.5.0!\r\n                        Fixed A Bug Where If You Stop The Project And Run It,\r\n                        All The Waits Will Run If They Are Not Over Yet.\r\n                        To Fix This, I Used An clearTimeout() Function For Each One.\r\n                         */\r\n                        vm.project.timeouts.push(setTimeout(() => {\r\n                                if (window.vm.control.running) {\r\n                                    callback();\r\n                                }\r\n                            }, secs * 1000)); /*1000ms = 1 second*/\r\n                    } catch (e) {}\r\n                },\r\n                getTouchMouse: function (spr) {\r\n                    return window.vm.___CHECKCOLLIDE({\r\n                        x: window.vm.project.mouseX,\r\n                        y: window.vm.project.mouseY,\r\n                        width: 1,\r\n                        height: 1\r\n                    }, spr);\r\n                },\r\n                changeColorEffect: function (img, r, g, b) {\r\n                    img.src = window.vm.renderer.getColorEffect(img, r, g, b);\r\n                },\r\n                micVolume: function () {\r\n                    if (window.vm.renderer.camrun) {\r\n                        return window.vm.renderer.micvol;\r\n                    } else {\r\n                        return 0;\r\n                    }\r\n                },\r\n                openCamera: function () {\r\n                    window.vm.renderer.startCameraStream();\r\n                },\r\n                stopCamera: function () {\r\n                    window.vm.renderer.stopCameraStream();\r\n                }\r\n            }\r\n        },\r\n        variables: {\r\n            canDrag: false\r\n        },\r\n        vmTick: function () {\r\n            if (vm.control.running) {\r\n                vm.project.timer = (vm.daysSince2000() * 86400) - vm.startTime;\r\n                for (var i in vm.project.events.tick) {\r\n                    try {\r\n                        vm.project.events.tick[i]()\r\n                    } catch (e) {\r\n                        vm.console.error(e);\r\n                    }\r\n                }\r\n                try {\r\n                    vm.renderer.tick(vm.project.sprites, vm.project.monitors);\r\n                } catch (e) {}\r\n                this.ticks += 0;\r\n                try {\r\n                    window.vm.ontick();\r\n                } catch (e) {\r\n                    console.error(e);\r\n                }\r\n            } else {\r\n                this.ticks = 0;\r\n            }\r\n            window.requestAnimationFrame(vm.vmTick);\r\n        },\r\n        start: function () {\r\n            vm.control.start();\r\n        },\r\n        stop: function () {\r\n            vm.control.stop();\r\n        },\r\n        setMousePos: function (data) {\r\n            this.project.mouseX = data.x;\r\n            this.project.mouseY = data.y;\r\n        },\r\n        setCloudAPI: function (api) {\r\n            this.cloudAPI = api;\r\n        },\r\n        setMouseDown: function (data) {\r\n            if (data == true) {\r\n                for (var i in vm.project.sprites) {\r\n                    try {\r\n                        if (this.___CHECKCOLLIDE({\r\n                                x: this.project.mouseX,\r\n                                y: this.project.mouseY,\r\n                                width: 1,\r\n                                height: 1\r\n                            }, vm.project.sprites[i])) {\r\n                            var currentSprite = vm.project.sprites[i];\r\n                            for (var i2 in currentSprite.clicked) {\r\n                                try {\r\n                                    currentSprite.clicked[i2]()\r\n                                } catch (e) {\r\n                                    vm.console.error(e);\r\n                                }\r\n                            }\r\n                            //console.log(\"clicked sprite.\");\r\n                        }\r\n                    } catch (e) {\r\n                        console.error(e);\r\n                    }\r\n                }\r\n            }\r\n            this.project.mouseDown = data;\r\n        },\r\n        console: {\r\n            log: function (text) {\r\n                console.log(text);\r\n            },\r\n            error: function (text) {\r\n                console.error(text);\r\n                vm.stop();\r\n            },\r\n            clear: function (text) {\r\n                console.clear();\r\n            }\r\n        },\r\n        simulateKey: function (data) {\r\n            if (data.down) {\r\n                this.project.keysPressed[data.key] = true;\r\n                if (this.project.keyListeners[data.key]) {\r\n                    this.project.keyListeners[data.key].forEach((func) => {\r\n                        try {\r\n                            func();\r\n                        } catch (e) {\r\n                            vm.console.error(e);\r\n                        }\r\n                    })\r\n                }\r\n            } else {\r\n                this.project.keysPressed[data.key] = false;\r\n            }\r\n        },\r\n        collideWidth: 0,\r\n        collideHeight: 0,\r\n        ___CHECKCOLLIDE: function (spr1, spr2) {\r\n            return false;\r\n        },\r\n        collideDiv: document.createElement(\"div\"),\r\n        addEventListener: function (name, eventName) {\r\n            this[\"on\" + name] = eventName;\r\n        },\r\n        ontick: function () {},\r\n        onspritecreate: function (sprite) {},\r\n        onstop: function () {},\r\n        __decodeDataBase64URI: function (dataURI) {\r\n            return atob(dataURI.split(\";\").pop().split(\",\").pop());\r\n        }\r\n    }\r\n    vm.___CHECKCOLLIDE = function isCollide(a2, b2) {\r\n        function getRealCanvasPos(x, y, width, height, canvas) {\r\n            var mainX = x - (width / 2);\r\n            var mainY = y - (height / 2);\r\n            return {\r\n                x: mainX - (canvas.width / 2),\r\n                y: mainY - (canvas.height / 2)\r\n            };\r\n        }\r\n        var a = {\r\n            width: a2.width / 2,\r\n            height: a2.height,\r\n            x: getRealCanvasPos(a2.x, a2.y, a2.width / 2, a2.height, vm.renderer.canvas).x,\r\n            y: getRealCanvasPos(a2.x, a2.y, a2.width / 2, a2.height, vm.renderer.canvas).y\r\n        };\r\n        var b = {\r\n            width: b2.width / 2,\r\n            height: b2.height,\r\n            x: getRealCanvasPos(b2.x, b2.y, b2.width / 2, b2.height, vm.renderer.canvas).x,\r\n            y: getRealCanvasPos(b2.x, b2.y, b2.width / 2, b2.height, vm.renderer.canvas).y\r\n        };\r\n        var result = (\r\n            a.x + a.width >= b.x &&\r\n            a.x <= b.x + b.width &&\r\n            a.y + a.height >= b.y &&\r\n            a.y <= b.y + b.height);\r\n        /*if (a2.image) {\r\n        document.body.appendChild(a2.image);\r\n        a2.image.style.position = 'fixed';\r\n        a2.image.style.top = a2.y+(vm.renderer.canvas.height / 2)+'px';\r\n        a2.image.style.left = a2.x+(vm.renderer.canvas.width / 2)+'px';\r\n        a2.image.width = a2.width;\r\n        a2.image.height = a2.height;\r\n        }\r\n        if (b2.image) {\r\n        document.body.appendChild(b2.image);\r\n        b2.image.style.position = 'fixed';\r\n        b2.image.style.top = b2.y+(vm.renderer.canvas.height / 2)+'px';\r\n        b2.image.style.left = b2.x+(vm.renderer.canvas.width / 2)+'px';\r\n        b2.image.width = b2.width;\r\n        b2.image.height = b2.height;\r\n        }*/\r\n        return result;\r\n    };\r\n    window.requestAnimationFrame(vm.vmTick);\r\n    /*\r\n    TEST SCRIPTS:\r\n    while in devlopment I ran code to check if everything is okay and working.\r\n    basic test:\r\n    var sprite = vm.project.block.makeSprite();\r\n    sprite.image = document.getElementById(\"testImage\");\r\n    \r\n    hide sprite test:\r\n    \r\n    vm.project.block.hideSprite(sprite);\r\n    \r\n    second sprite test:\r\n    \r\n    var sprite2 = vm.project.block.makeSprite();\r\n    sprite2.image = document.getElementById(\"testImage\");\r\n    \r\n    rotating sprite test:\r\n    var sprite3 = vm.project.block.makeSprite();\r\n    sprite3.image = document.getElementById(\"testImage\");\r\n    vm.project.events.tick.push(function () {\r\n    sprite3.direction += 1;\r\n    });\r\n    */\r\n    \n    return module;\n})();",
   "name": "src\\ggm2\\ggm-vm\\index.js",
   "dirname": "src_ggm2_ggm-vm_index.js",
   "realdir": "src_ggm2_ggm-vm_index.js",
   "realdirNoReplacer": "src\\ggm2\\ggm-vm\\index.js",
   "uncompileddata": "var console = require(\"log\");\r\nvar ggm2path = require(\"src/paths.js\");\r\nvar Sprite = require(\"src/\" + ggm2path + \"/ggm-vm/classes/sprite.js\");\r\nwindow.vm = {\r\n    daysSince2000: function () {\r\n        const msPerDay = 24 * 60 * 60 * 1000;\r\n        const start = new Date(2000, 0, 1); // Months are 0-indexed.\r\n        const today = new Date();\r\n        const dstAdjust = today.getTimezoneOffset() - start.getTimezoneOffset();\r\n        let mSecsSinceStart = today.valueOf() - start.valueOf();\r\n        mSecsSinceStart += ((today.getTimezoneOffset() - dstAdjust) * 60 * 1000);\r\n        return mSecsSinceStart / msPerDay;\r\n    },\r\n    messageData: [],\r\n    idcounter: 0,\r\n    startTime: 0,\r\n    resetTimer: () => {\r\n        vm.startTime = vm.daysSince2000() * 86400;\r\n        vm.project.timer = 0;\r\n    },\r\n    control: {\r\n        start: async function (a) {\r\n            if (vm.audioEngine) {\r\n                if (vm.renderer) {\r\n                    for (var m of vm.messageData) {\r\n                        vm.messages[m] = [];\r\n                    }\r\n                    vm.control.stop();\r\n                    vm.resetTimer();\r\n                    vm.control.running = true;\r\n                    vm.idcounter = 0;\r\n                    vm.project.monitors = [];\r\n                    window.vm.renderer.camghost = 0;\r\n                    window.vm.renderer.bg.src = \"\";\r\n                    try {\r\n                        eval(\"(async function () {\\ntry{\\n\" + vm.code + \"\\n} catch (e) {\\nvm.console.error(e);\\n}\\n})();\");\r\n                    } catch (e) {\r\n                        vm.console.error(\"Error in script:\" + e);\r\n                    }\r\n                } else {\r\n                    throw Error(\"Renderer Must Be Attached\");\r\n                }\r\n            } else {\r\n                throw Error(\"AudioEngine Must Be Attached\");\r\n            }\r\n        },\r\n        stop: function () {\r\n            for (var i in vm.project.timeouts) {\r\n                clearTimeout(vm.project.timeouts[i]);\r\n            }\r\n            vm.project.timeouts = [];\r\n            vm.idcounter = 0;\r\n            vm.control.running = false;\r\n            vm.project.sprites = [];\r\n            vm.project.events.tick = [];\r\n            vm.project.sprites = [];\r\n            vm.project.keysPressed = [];\r\n            vm.project.keyListeners = {};\r\n            vm.audioEngine.stop();\r\n            try {\r\n                window.vm.onstop();\r\n            } catch (e) {\r\n                console.error(e);\r\n            }\r\n        },\r\n        running: false\r\n    },\r\n    code: \"\",\r\n    renderer: null,\r\n    attachRenderer: function (a) {\r\n        vm.renderer = a;\r\n        vm.renderer.start();\r\n        return a;\r\n    },\r\n    attachAudioEngine: function (a) {\r\n        vm.audioEngine = a;\r\n        return a;\r\n    },\r\n    setCompiadiblityMode: function (a) {\r\n        this.compiadiblityMode = a;\r\n    },\r\n    compiadiblityMode: false,\r\n    messages: {},\r\n    project: {\r\n        keyListeners: {},\r\n        mouseDown: false,\r\n        mouseX: 0,\r\n        mouseY: 0,\r\n        keysPressed: [],\r\n        sprites: [],\r\n        events: {\r\n            tick: []\r\n        },\r\n        monitors: [],\r\n        resources: [],\r\n        timer: 0,\r\n        timeouts: [],\r\n        block: {\r\n            convertURLToText: function (url) {\r\n                try {\r\n                    return atob(url.split(\",\").pop());\r\n                } catch (e) {\r\n                    vm.console.error(\"Error in script:\" + e);\r\n                }\r\n            },\r\n\t\t\tcloudVarSet: function (name, value) {\r\n                try {\r\n                    if (vm.cloudAPI) {\r\n                        vm.cloudAPI.updateVariable(name, value);\r\n                    }\r\n                } catch (e) {\r\n                    vm.console.error(\"Error in script:\" + e);\r\n                }\r\n            },\r\n            cloudVarGet: function (name) {\r\n                try {\r\n                    if (vm.cloudAPI) {\r\n                        var realValue = vm.cloudAPI.getVariable(name);\r\n                        //so users can understand the blocks easier\r\n                        if (Number(realValue)) {\r\n                            realValue = Number(realValue);\r\n                        }\r\n                        return realValue;\r\n                    }\r\n                } catch (e) {\r\n                    vm.console.error(\"Error in script:\" + e);\r\n                }\r\n            },\r\n            tickAsync: function () {\r\n                return new Promise((a) => {\r\n                    setTimeout(a, 1);\r\n                })\r\n            },\r\n\t\t\tsaveFileFromText: function (name,type,contents) {\r\n\t\t\t\tvar myFile = new Blob([contents], {\r\n\t\t\t\t\ttype: type\r\n\t\t\t\t});\r\n\t\t\t\t\r\n\t\t\t\tvar objectURL = window.URL || window.webkitURL;\r\n\t\t\t\tvar a = document.createElement(\"a\");\r\n\r\n\t\t\t\ta.href = objectURL.createObjectURL(myFile);\r\n\t\t\t\ta.download = name;\r\n\t\t\t\ta.click();\r\n\t\t\t},\r\n\t\t\tloadFileAsText: function (extensions,callback) {\r\n\t\t\t\tvar objectURL = window.URL || window.webkitURL;\r\n\t\t\t\tvar input = document.createElement(\"input\");\r\n\t\t\t\tinput.type = \"file\";\r\n\t\t\t\tinput.accept = extensions;\r\n\t\t\t\tinput.click();\r\n\t\t\t\t\r\n\t\t\t\tinput.onchange = function () {\r\n\t\t\t\t\tif (input.files.length > 0) {\r\n\t\t\t\t\t\tvar file = input.files[0];\r\n\t\t\t\t\t\tvar reader = new FileReader();\r\n\t\t\t\t\t\treader.onload = function () {\r\n\t\t\t\t\t\t\tcallback(reader.result);\r\n\t\t\t\t\t\t\tinput.remove();\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t\treader.readAsText(file);\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\t\t\t},\r\n            waitAsync: function (s) {\r\n                return new Promise((a) => {\r\n                    vm.project.timeouts.push(setTimeout(a, s * 1000));\r\n                })\r\n            },\r\n            moveSteps: function (sprite, steps) {\r\n                try {\r\n                    var realsteps = steps;\r\n                    var realdir = 90 - sprite.direction;\r\n                    var xBy = Math.cos(realdir * (Math.PI / 180)) * realsteps;\r\n                    var yBy = Math.sin(realdir * (Math.PI / 180)) * realsteps;\r\n                    var realxby = xBy + xBy;\r\n                    sprite.x = sprite.x + realxby;\r\n                    sprite.y = sprite.y + (yBy + yBy);\r\n                } catch (e) {\r\n                    vm.console.error(\"Error in script:\" + e);\r\n                }\r\n            },\r\n            deleteList: function (array, number) {\r\n                try {\r\n                    delete array[number];\r\n                    var index = 0;\r\n                    var genaratedArray = [];\r\n                    while (array.length > index) {\r\n                        if (!(array[index] == undefined)) {\r\n                            genaratedArray.push(array[index]);\r\n                        }\r\n                        index += 1;\r\n                    }\r\n                    return genaratedArray;\r\n                } catch (e) {\r\n                    vm.console.error(\"Error in script:\" + e);\r\n                }\r\n            },\r\n            makeSprite: function () {\r\n                try {\r\n                    vm.idcounter += 1;\r\n\t\t\t\t\tvar realID = vm.project.sprites.length-1;\r\n                    var spr = new Sprite(realID);\r\n                    this.showSprite(spr);\r\n                    return spr;\r\n                    try {\r\n                        window.vm.onspritecreate(spr);\r\n                    } catch (e) {\r\n                        console.error(e);\r\n                    }\r\n                } catch (e) {}\r\n\r\n            },\r\n            makeMonitor: function () {\r\n                try {\r\n                    var monitor = {\r\n                        x: 0,\r\n                        y: 0,\r\n                        value: 0,\r\n                        name: \"monitor\",\r\n                        visible: true,\r\n                        clicked: []\r\n                    };\r\n                    window.vm.project.monitors.push(monitor);\r\n                    return monitor;\r\n                } catch (e) {\r\n                    vm.console.error(\"Error in script:\" + e);\r\n                }\r\n            },\r\n            showSprite: function (spr) {\r\n                try {\r\n                    this.hideSprite(spr); //ensure there is only one sprite when showing again.\r\n                    vm.project.sprites.push(spr);\r\n\t\t\t\t\tvar counter = 0;\r\n\t\t\t\t\tfor (var spr2 of vm.project.sprites) {\r\n\t\t\t\t\t\tspr2.id = counter;\r\n\t\t\t\t\t\tcounter += 1;\r\n\t\t\t\t\t}\r\n                } catch (e) {\r\n                    vm.console.error(\"Error in script:\" + e);\r\n                }\r\n            },\r\n            hideSprite: function (spr) {\r\n                try {\r\n                    var i = vm.project.sprites.indexOf(spr);\r\n                    if (i > -1) {\r\n                        vm.project.sprites.splice(i, 1); // 2nd parameter means remove one item only\r\n                    }\r\n\t\t\t\t\t\r\n\t\t\t\t\tvar counter = 0;\r\n\t\t\t\t\tfor (var spr2 of vm.project.sprites) {\r\n\t\t\t\t\t\tspr2.id = counter;\r\n\t\t\t\t\t\tcounter += 1;\r\n\t\t\t\t\t}\r\n                } catch (e) {}\r\n            },\r\n            cos: function (number) {\r\n                try {\r\n                    return Math.cos((number) * (Math.PI / 180));\r\n                } catch (e) {\r\n                    vm.console.error(e);\r\n                }\r\n            },\r\n            sin: function (number) {\r\n                try {\r\n                    return Math.sin((number) * (Math.PI / 180));\r\n                } catch (e) {\r\n                    vm.console.error(e);\r\n                }\r\n            },\r\n            getMoseData: function () {\r\n                try {\r\n                    return {\r\n                        x: vm.project.mouseX,\r\n                        y: vm.project.mouseY,\r\n                        down: vm.project.mouseDown\r\n                    };\r\n                } catch (e) {}\r\n            },\r\n            dataToImg: function (dataURI) {\r\n                try {\r\n                    var img = document.createElement(\"img\");\r\n                    img.src = dataURI;\r\n                    img.setAttribute(\"style\", \"image-rendering: pixelated;\");\r\n                    return img;\r\n                } catch (e) {}\r\n            },\r\n            random: function (a, b) {\r\n                if (a > b) {\r\n                    // Swap a and b to ensure a is smaller.\r\n                    var c = a;\r\n                    a = b;\r\n                    b = c;\r\n                }\r\n                return Math.floor(Math.random() * (b - a + 1) + a);\r\n            },\r\n            isTouching: function (sprite1, sprite2, mode) {\r\n                /*if (sp1.x > sp2.x) {\r\n                var devideNumX = -2;\r\n                } else {\r\n                var devideNumX = 2;\r\n                }\r\n                sp1.x -= sp1.width/devideNumX;\r\n                var res = (\r\n                sp1.x < sp2.x + (sp2.width/1) &&\r\n                sp1.x + (sp1.width/1) > sp2.x &&\r\n                sp1.y < sp2.y + sp2.height &&\r\n                sp1.height + sp1.y > sp2.y\r\n                );\r\n                sp1.x += sp1.width/devideNumX;\r\n                return res;*/\r\n                try {\r\n                    return vm.___CHECKCOLLIDE(sprite1, sprite2);\r\n                } catch (e) {\r\n                    vm.console.error(\"Error in script:\" + e);\r\n                }\r\n            },\r\n            getKeyPressed: function (keyname) {\r\n                try {\r\n                    if (vm.project.keysPressed[keyname]) {\r\n                        return true;\r\n                    } else {\r\n                        return false;\r\n                    }\r\n                } catch (e) {}\r\n            },\r\n            wait: function (secs, callback) {\r\n                try {\r\n                    /**Update For V1.5.0!\r\n                    Fixed A Bug Where If You Stop The Project And Run It,\r\n                    All The Waits Will Run If They Are Not Over Yet.\r\n                    To Fix This, I Used An clearTimeout() Function For Each One.\r\n                     */\r\n                    vm.project.timeouts.push(setTimeout(() => {\r\n                            if (window.vm.control.running) {\r\n                                callback();\r\n                            }\r\n                        }, secs * 1000)); /*1000ms = 1 second*/\r\n                } catch (e) {}\r\n            },\r\n            getTouchMouse: function (spr) {\r\n                return window.vm.___CHECKCOLLIDE({\r\n                    x: window.vm.project.mouseX,\r\n                    y: window.vm.project.mouseY,\r\n                    width: 1,\r\n                    height: 1\r\n                }, spr);\r\n            },\r\n            changeColorEffect: function (img, r, g, b) {\r\n                img.src = window.vm.renderer.getColorEffect(img, r, g, b);\r\n            },\r\n            micVolume: function () {\r\n                if (window.vm.renderer.camrun) {\r\n                    return window.vm.renderer.micvol;\r\n                } else {\r\n                    return 0;\r\n                }\r\n            },\r\n            openCamera: function () {\r\n                window.vm.renderer.startCameraStream();\r\n            },\r\n            stopCamera: function () {\r\n                window.vm.renderer.stopCameraStream();\r\n            }\r\n        }\r\n    },\r\n    variables: {\r\n        canDrag: false\r\n    },\r\n    vmTick: function () {\r\n        if (vm.control.running) {\r\n            vm.project.timer = (vm.daysSince2000() * 86400) - vm.startTime;\r\n            for (var i in vm.project.events.tick) {\r\n                try {\r\n                    vm.project.events.tick[i]()\r\n                } catch (e) {\r\n                    vm.console.error(e);\r\n                }\r\n            }\r\n            try {\r\n                vm.renderer.tick(vm.project.sprites, vm.project.monitors);\r\n            } catch (e) {}\r\n            this.ticks += 0;\r\n            try {\r\n                window.vm.ontick();\r\n            } catch (e) {\r\n                console.error(e);\r\n            }\r\n        } else {\r\n            this.ticks = 0;\r\n        }\r\n        window.requestAnimationFrame(vm.vmTick);\r\n    },\r\n    start: function () {\r\n        vm.control.start();\r\n    },\r\n    stop: function () {\r\n        vm.control.stop();\r\n    },\r\n    setMousePos: function (data) {\r\n        this.project.mouseX = data.x;\r\n        this.project.mouseY = data.y;\r\n    },\r\n    setCloudAPI: function (api) {\r\n        this.cloudAPI = api;\r\n    },\r\n    setMouseDown: function (data) {\r\n        if (data == true) {\r\n            for (var i in vm.project.sprites) {\r\n                try {\r\n                    if (this.___CHECKCOLLIDE({\r\n                            x: this.project.mouseX,\r\n                            y: this.project.mouseY,\r\n                            width: 1,\r\n                            height: 1\r\n                        }, vm.project.sprites[i])) {\r\n                        var currentSprite = vm.project.sprites[i];\r\n                        for (var i2 in currentSprite.clicked) {\r\n                            try {\r\n                                currentSprite.clicked[i2]()\r\n                            } catch (e) {\r\n                                vm.console.error(e);\r\n                            }\r\n                        }\r\n                        //console.log(\"clicked sprite.\");\r\n                    }\r\n                } catch (e) {\r\n                    console.error(e);\r\n                }\r\n            }\r\n        }\r\n        this.project.mouseDown = data;\r\n    },\r\n    console: {\r\n        log: function (text) {\r\n            console.log(text);\r\n        },\r\n        error: function (text) {\r\n            console.error(text);\r\n            vm.stop();\r\n        },\r\n        clear: function (text) {\r\n            console.clear();\r\n        }\r\n    },\r\n    simulateKey: function (data) {\r\n        if (data.down) {\r\n            this.project.keysPressed[data.key] = true;\r\n            if (this.project.keyListeners[data.key]) {\r\n                this.project.keyListeners[data.key].forEach((func) => {\r\n                    try {\r\n                        func();\r\n                    } catch (e) {\r\n                        vm.console.error(e);\r\n                    }\r\n                })\r\n            }\r\n        } else {\r\n            this.project.keysPressed[data.key] = false;\r\n        }\r\n    },\r\n    collideWidth: 0,\r\n    collideHeight: 0,\r\n    ___CHECKCOLLIDE: function (spr1, spr2) {\r\n        return false;\r\n    },\r\n    collideDiv: document.createElement(\"div\"),\r\n    addEventListener: function (name, eventName) {\r\n        this[\"on\" + name] = eventName;\r\n    },\r\n    ontick: function () {},\r\n    onspritecreate: function (sprite) {},\r\n    onstop: function () {},\r\n    __decodeDataBase64URI: function (dataURI) {\r\n        return atob(dataURI.split(\";\").pop().split(\",\").pop());\r\n    }\r\n}\r\nvm.___CHECKCOLLIDE = function isCollide(a2, b2) {\r\n    function getRealCanvasPos(x, y, width, height, canvas) {\r\n        var mainX = x - (width / 2);\r\n        var mainY = y - (height / 2);\r\n        return {\r\n            x: mainX - (canvas.width / 2),\r\n            y: mainY - (canvas.height / 2)\r\n        };\r\n    }\r\n    var a = {\r\n        width: a2.width / 2,\r\n        height: a2.height,\r\n        x: getRealCanvasPos(a2.x, a2.y, a2.width / 2, a2.height, vm.renderer.canvas).x,\r\n        y: getRealCanvasPos(a2.x, a2.y, a2.width / 2, a2.height, vm.renderer.canvas).y\r\n    };\r\n    var b = {\r\n        width: b2.width / 2,\r\n        height: b2.height,\r\n        x: getRealCanvasPos(b2.x, b2.y, b2.width / 2, b2.height, vm.renderer.canvas).x,\r\n        y: getRealCanvasPos(b2.x, b2.y, b2.width / 2, b2.height, vm.renderer.canvas).y\r\n    };\r\n    var result = (\r\n        a.x + a.width >= b.x &&\r\n        a.x <= b.x + b.width &&\r\n        a.y + a.height >= b.y &&\r\n        a.y <= b.y + b.height);\r\n    /*if (a2.image) {\r\n    document.body.appendChild(a2.image);\r\n    a2.image.style.position = 'fixed';\r\n    a2.image.style.top = a2.y+(vm.renderer.canvas.height / 2)+'px';\r\n    a2.image.style.left = a2.x+(vm.renderer.canvas.width / 2)+'px';\r\n    a2.image.width = a2.width;\r\n    a2.image.height = a2.height;\r\n    }\r\n    if (b2.image) {\r\n    document.body.appendChild(b2.image);\r\n    b2.image.style.position = 'fixed';\r\n    b2.image.style.top = b2.y+(vm.renderer.canvas.height / 2)+'px';\r\n    b2.image.style.left = b2.x+(vm.renderer.canvas.width / 2)+'px';\r\n    b2.image.width = b2.width;\r\n    b2.image.height = b2.height;\r\n    }*/\r\n    return result;\r\n};\r\nwindow.requestAnimationFrame(vm.vmTick);\r\n/*\r\nTEST SCRIPTS:\r\nwhile in devlopment I ran code to check if everything is okay and working.\r\nbasic test:\r\nvar sprite = vm.project.block.makeSprite();\r\nsprite.image = document.getElementById(\"testImage\");\r\n\r\nhide sprite test:\r\n\r\nvm.project.block.hideSprite(sprite);\r\n\r\nsecond sprite test:\r\n\r\nvar sprite2 = vm.project.block.makeSprite();\r\nsprite2.image = document.getElementById(\"testImage\");\r\n\r\nrotating sprite test:\r\nvar sprite3 = vm.project.block.makeSprite();\r\nsprite3.image = document.getElementById(\"testImage\");\r\nvm.project.events.tick.push(function () {\r\nsprite3.direction += 1;\r\n});\r\n*/\r\n"
  },
  "src_ggm2_ggm-vm_renderer.js": {
   "data": "(function () {\n//ignore these variables, for the module stuff.\n    var module = {exports:null,filename:JSON.stringify(name)};\n    var require = function (a) {return gp_require(a,\"src\\\\ggm2\\\\ggm-vm\\\\renderer.js\");};\n    var var__gvbvdxx_pack_filedata = null; //prevent overwrite\n    var cur_file = \"src\\\\ggm2\\\\ggm-vm\\\\renderer.js\";\n    var console = require(\"log\");\r\n    window.renderer = {\r\n        canvas: null,\r\n        bg: document.createElement(\"img\"),\r\n        backgroundImg:null,\r\n        getUserMedia: function (a) {\r\n            return new Promise((resolve, reject) => {\r\n                navigator.getUserMedia(a, resolve, ()=>{resolve(\"CamDenied\");});\r\n            });\r\n        },\r\n        camcanvas:document.createElement(\"canvas\"),\r\n        camcontext:null,\r\n        camvid:document.createElement(\"video\"),\r\n        camrun:false,\r\n        startCameraStream: async function () {\r\n            if (!(this.camrun)) {\r\n                //not to creep out the user from thinking that they are trying to get spyed on...\r\n                var stream = await this.getUserMedia({\r\n                    video: true,\r\n                    audio: true\r\n                });\r\n                if (stream == \"CamDenied\") {\r\n                    return; //denied access (do they think that they are trying to get spyed on?)\r\n                }\r\n                //ok! we got access, so now we need to use it!\r\n                this.camstream = stream;\r\n                this.camvid.srcObject = stream;\r\n                this.camcanvas.width = this.camvid.width;\r\n                this.camcanvas.height = this.camvid.width;\r\n                this.camrun = true;\r\n                var audioContext = window.vm.audioEngine.context;\r\n                var analyser = audioContext.createAnalyser();\r\n                var microphone = audioContext.createMediaStreamSource(stream);\r\n    \r\n                analyser.smoothingTimeConstant = 0.8;\r\n                analyser.fftSize = 1024;\r\n                var rend = this;\r\n                microphone.connect(analyser);\r\n                this.caminterval = setInterval(function () {\r\n                    var array = new Uint8Array(analyser.frequencyBinCount);\r\n                    analyser.getByteFrequencyData(array);\r\n                    var arraySum = array.reduce((a, value) => a + value, 0);\r\n                    var average = arraySum / array.length;\r\n                    rend.micvol = average/200*100;\r\n                    // colorPids(average);\r\n                },1);\r\n            }\r\n        },\r\n        stopCameraStream: async function () {\r\n            //quick check to see if we are running the camrea\r\n            if (this.camrun) {\r\n                this.camrun = false; //stop rendering the camrea!\r\n                //stop recording video!\r\n                renderer.camstream.getVideoTracks().forEach((t) => {\r\n                    t.stop();\r\n                });\r\n                //stop recording audio!\r\n                renderer.camstream.getAudioTracks().forEach((t) => {\r\n                    t.stop();\r\n                });\r\n                //end video!\r\n                this.camvid.pause();\r\n                this.camvid.srcObject = null;\r\n                this.camstream = null;\r\n                clearInterval(this.caminterval);\r\n            }\r\n        },\r\n        start: function () {\r\n            this.context = this.canvas.getContext(\"2d\");\r\n            this.context.globalAlpha = 1;\r\n            this.context.strokeStyle = this.color;\r\n            this.context.fillStyle = this.color;\r\n            this.context.beginPath();\r\n            this.context.fillRect(0, 0, this.canvas.width + 2, this.canvas.height + 2);\r\n            this.context.stroke();\r\n            this.test=0;\r\n            this.canvas.style.imageRendering = \"Pixelated\";\r\n        },\r\n        camghost: 0,\r\n        tick: function (sprites,monitors) {\r\n            this.events.tick.forEach((funct) => {\r\n                try{\r\n                    funct();\r\n                }catch(e){console.error(\"renderer ran event, but an error was thrown.\",e)}\r\n            });\r\n            this.context.globalAlpha = 1;\r\n            this.context.fillStyle = this.color;\r\n            this.context.strokeStyle = this.color;\r\n            this.context.beginPath();\r\n            this.context.fillRect(0, 0, this.canvas.width + 2, this.canvas.height + 2);\r\n            this.context.stroke();\r\n            this.context.webkitImageSmoothingEnabled = false;\r\n            this.context.mozImageSmoothingEnabled = false;\r\n            this.context.imageSmoothingEnabled = false;\r\n            if (this.camrun) {\r\n                this.camcontext.globalAlpha = 1;\r\n                this.camcontext.drawImage(this.camvid,0,0,this.camcanvas.width,this.camcanvas.height);\r\n                this.context.globalAlpha = 1 - (this.camghost / 100);\r\n                this.context.drawImage(this.camvid,0,0,this.canvas.width,this.canvas.height);\r\n                this.context.globalAlpha = 1;\r\n            }\r\n            try{\r\n                this.context.drawImage(this.bg,0,0,this.canvas.width,this.canvas.height);\r\n            }catch(e){}\r\n            for (var i in sprites) {\r\n                sprites[i];\r\n                this._drawSprite(sprites[i]);\r\n            }\r\n            for (var i in monitors) {\r\n                monitors[i];\r\n                this._drawMonitor(monitors[i]);\r\n            }\r\n            this.events.ticked.forEach((funct) => {\r\n                try{\r\n                    funct();\r\n                }catch(e){console.error(\"renderer ran event, but an error was thrown.\",e)}\r\n            });\r\n        },\r\n        events:{\r\n            beforedraw:[],\r\n            afterdraw:[],\r\n            drawsprite:[],\r\n            beforemonitordraw:[],\r\n            aftermonitordraw:[],\r\n            tick:[],\r\n            ticked:[]\r\n        },\r\n        addEventListener: function (name,funct) {\r\n            if (this.events[name.toLowerCase()]) {\r\n                this.events[name.toLowerCase()].push(funct);\r\n            } else {\r\n                console.warn(\"renderer tried adding event \\\"\"+name+\"\\\" but cant find it. check the spelling and try again.\");\r\n            }\r\n        },\r\n        width:600,\r\n        height:360,\r\n        getScaleInfo: function (x,y,width,height) {\r\n            var sw = this.canvas.width/this.width;\r\n            var sh = this.canvas.height/this.height;\r\n            return {\r\n                x:Math.round(sw*x),\r\n                y:Math.round(sh*y),\r\n                w:Math.round(sw*width),\r\n                h:Math.round(sh*height),\r\n                scalewidth:sw,\r\n                scaleheight:sh\r\n            };\r\n        },\r\n        drawImage: function (img,x,y,w,h) {\r\n            var si = this.getScaleInfo(x,y,w,h);\r\n            this.context.drawImage(img,si.x,si.y,si.w,si.h);\r\n        },\r\n        translate: function (x,y) {\r\n            var si = this.getScaleInfo(x,y,0,0);\r\n            this.context.translate(si.x,si.y);\r\n        },\r\n        _drawSprite: function (json) {\r\n            this.events.beforedraw.forEach((funct) => {\r\n                try{\r\n                    funct();\r\n                }catch(e){console.error(\"renderer ran event, but an error was thrown.\",e)}\r\n            });\r\n            this.context.save();\r\n            //use the try to not throw an error when renderering failed, so the renderer keeps ticking.\r\n            try{\r\n                this.events.drawsprite.forEach((funct) => {\r\n                    try{\r\n                        funct(json);\r\n                    }catch(e){console.error(\"renderer ran event, but an error was thrown.\",e)}\r\n                });\r\n                var __calculated_x = json.x;\r\n                var __calculated_y = 0 - json.y;\r\n                var ghost = json.ghost;\r\n                if (ghost > 100) {\r\n                    ghost = 100;\r\n                }\r\n                if (ghost < 0) {\r\n                    ghost = 0;\r\n                }\r\n                this.context.globalAlpha = 1 - (ghost / 100);\r\n                //this.context.translate(this.canvas.width/2+json.x+__calculated_x, this.canvas.height/2+__calculated_y);\r\n                this.translate(this.width/2+json.x+__calculated_x, this.height/2+__calculated_y); //this moves the image to the sprite position.\r\n                this.context.rotate((json.direction - 90)*Math.PI/180);\r\n                if (json.flip == \"hor\") {\r\n                    this.context.scale(-1,1);\r\n                } else {\r\n                    if (json.flip == \"ver\") {\r\n                        this.context.scale(1,-1);\r\n                    }\r\n                }\r\n                this.drawImage(json.image, json.width/-2, json.height/-2, json.width, json.height); //draw the image and offset it so it rotates in the center.\r\n            }catch(e){}\r\n            this.context.restore();\r\n            this.events.afterdraw.forEach((funct) => {\r\n                try{\r\n                    funct();\r\n                }catch(e){console.error(\"renderer ran event, but an error was thrown.\",e)}\r\n            });\r\n        },\r\n        _drawMonitor: function (json) {\r\n            //Scale Update!!\r\n            //this also fixes some bugs when rendering vars\r\n            this.events.beforemonitordraw.forEach((funct) => {\r\n                try{\r\n                    funct();\r\n                }catch(e){console.error(\"renderer ran event, but an error was thrown.\",e)}\r\n            });\r\n            this.context.save();\r\n            //use the try to not throw an error when renderering failed, so the renderer keeps ticking.\r\n            try{\r\n                if (json.visible) {\r\n                    this.context.globalAlpha = 1;\r\n                    this.context.translate(0,0);\r\n                    var textscale = this.getScaleInfo().scalewidth;\r\n                    renderer.context.font = 'bold '+(15*this.getScaleInfo().scalewidth)+'px arial';\r\n                    var textWidth = renderer.context.measureText(json.value).width/textscale;\r\n                    var textNameWidth = renderer.context.measureText(json.name).width/textscale;\r\n                    this.context.globalAlpha = 1;\r\n                    renderer.context.fillStyle = \"#868e96\";\r\n                    renderer.fillRect(Math.round(json.x-2),Math.round(json.y-2),Math.round(24+textNameWidth+textWidth),Math.round(24));\r\n                    renderer.context.fillStyle = \"#ced4da\";\r\n                    renderer.fillRect(Math.round(json.x),Math.round(json.y),Math.round(20+textNameWidth+textWidth),Math.round(20));    \r\n                    renderer.context.fillStyle = \"#ff8c00\";\r\n                    renderer.fillRect(Math.round(json.x+textNameWidth+10),Math.round(json.y+3),Math.round(5+textWidth),Math.round(15));\r\n                    renderer.context.fillStyle = \"white\";\r\n                    renderer.fillText(json.value, Math.round(json.x+textNameWidth+12),Math.round(json.y + 16));\r\n                    renderer.context.fillStyle = \"black\";\r\n                    renderer.fillText(json.name, Math.round(json.x + 6),Math.round(json.y + 15));\r\n                    return {\r\n                        width:Math.round(74+textNameWidth+textWidth),\r\n                        height:Math.round(24),\r\n                        x:Math.round(json.x),\r\n                        y:Math.round(json.y)\r\n                    };\r\n                }\r\n            }catch(e){console.error(e);}\r\n            this.context.restore();\r\n            this.events.aftermonitordraw.forEach((funct) => {\r\n                try{\r\n                    funct();\r\n                }catch(e){console.error(\"renderer ran event, but an error was thrown.\",e)}\r\n            });\r\n        },\r\n        fillRect: function (x,y,w,h) {\r\n            var si = this.getScaleInfo(x,y,w,h);\r\n            this.context.fillRect(Math.round(si.x),Math.round(si.y),Math.round(si.w),Math.round(si.h));\r\n        },\r\n        fillText: function (txt,x,y) {\r\n            var si = this.getScaleInfo(x,y,0,0);\r\n            this.context.fillText(txt,Math.round(si.x),Math.round(si.y));\r\n        },\r\n        color:\"#ffffff\",\r\n        getColorEffect: function (img,r,g,b) {\r\n            try{\r\n                var cvs = document.createElement(\"canvas\");\r\n                var ctx = cvs.getContext(\"2d\");\r\n                cvs.width = img.width;\r\n                cvs.height = img.height;\r\n                ctx.drawImage(img,0,0,cvs.width,cvs.height);\r\n                var imgdata = ctx.getImageData(0,0,cvs.width,cvs.height);\r\n                var imageData = imgdata.data;\r\n                for (let i = 0; i < imageData.length; i += 4) {\r\n                    imageData[i] += r;\r\n                    imageData[i+1] += g;\r\n                    imageData[i+2] += g;\r\n                }\r\n                ctx.putImageData(imgdata,0,0);\r\n                return cvs.toDataURL();\r\n            }catch(e){console.error(e);}\r\n        },\r\n        getRandomColorEffect: function (img,randomness) {\r\n            try{\r\n                var cvs = document.createElement(\"canvas\");\r\n                var ctx = cvs.getContext(\"2d\");\r\n                cvs.width = img.width;\r\n                cvs.height = img.height;\r\n                ctx.drawImage(img,0,0,cvs.width,cvs.height);\r\n                var imgdata = ctx.getImageData(0,0,cvs.width,cvs.height);\r\n                var imageData = imgdata.data;\r\n                for (let i = 0; i < imageData.length; i += 4) {\r\n                    imageData[i] += Math.random()*randomness;\r\n                    imageData[i+1] += Math.random()*randomness;\r\n                    imageData[i+2] += Math.random()*randomness;\r\n                }\r\n                ctx.putImageData(imgdata,0,0);\r\n                return cvs.toDataURL();\r\n            }catch(e){console.error(e);}\r\n        },\r\n        getGlitchColorEffect: function (img,randomness) {\r\n            try{\r\n                var cvs = document.createElement(\"canvas\");\r\n                var ctx = cvs.getContext(\"2d\");\r\n                cvs.width = img.width;\r\n                cvs.height = img.height;\r\n                ctx.drawImage(img,0,0,cvs.width,cvs.height);\r\n                var imgdata = ctx.getImageData(0,0,cvs.width,cvs.height);\r\n                var imageData = imgdata.data;\r\n                for (let i = 0; i < imageData.length; i += 4) {\r\n                    imageData[i] = Math.random()*randomness;\r\n                    imageData[i+1] = Math.random()*randomness;\r\n                    imageData[i+2] = Math.random()*randomness;\r\n                }\r\n                ctx.putImageData(imgdata,0,0);\r\n                return cvs.toDataURL();\r\n            }catch(e){console.error(e);}\r\n        },\r\n        getInvertColorEffect: function (img) {\r\n            try{\r\n                var cvs = document.createElement(\"canvas\");\r\n                var ctx = cvs.getContext(\"2d\");\r\n                cvs.width = img.width;\r\n                cvs.height = img.height;\r\n                ctx.drawImage(img,0,0,cvs.width,cvs.height);\r\n                var imgdata = ctx.getImageData(0,0,cvs.width,cvs.height);\r\n                var imageData = imgdata.data;\r\n                for (let i = 0; i < imageData.length; i += 4) {\r\n                    var r = imageData[i];\r\n                    var g = imageData[i+1];\r\n                    var b = imageData[i+2];\r\n                    imageData[i] = b;\r\n                    imageData[i+1] = g;\r\n                    imageData[i+2] = r;\r\n                }\r\n                ctx.putImageData(imgdata,0,0);\r\n                return cvs.toDataURL();\r\n            }catch(e){console.error(e);}\r\n        },\r\n        getInvertColorEffect: function (img) {\r\n            try{\r\n                var cvs = document.createElement(\"canvas\");\r\n                var ctx = cvs.getContext(\"2d\");\r\n                cvs.width = img.width;\r\n                cvs.height = img.height;\r\n                ctx.drawImage(img,0,0,cvs.width,cvs.height);\r\n                var imgdata = ctx.getImageData(0,0,cvs.width,cvs.height);\r\n                var imageData = imgdata.data;\r\n                for (let i = 0; i < imageData.length; i += 4) {\r\n                    var r = imageData[i];\r\n                    var g = imageData[i+1];\r\n                    var b = imageData[i+2];\r\n                    imageData[i] = b;\r\n                    imageData[i+1] = g;\r\n                    imageData[i+2] = r;\r\n                }\r\n                ctx.putImageData(imgdata,0,0);\r\n                return cvs.toDataURL();\r\n            }catch(e){console.error(e);}\r\n        },\r\n        componentToHex:function (c) {\r\n          var hex = c.toString(16);\r\n          return hex.length == 1 ? \"0\" + hex : hex;\r\n        },\r\n        rgbToHex:function (r, g, b) {\r\n          return \"#\" + this.componentToHex(r) + this.componentToHex(g) + this.componentToHex(b);\r\n        },\r\n        hexToRgb:function (hex) {\r\n            var result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\r\n            return result ? {\r\n                r: parseInt(result[1], 16),\r\n                g: parseInt(result[2], 16),\r\n                b: parseInt(result[3], 16)\r\n            }\r\n             : null;\r\n        },\r\n        getColorAtPos: function (x,y) {\r\n            var __calculated_x = x;\r\n            var __calculated_y = 0 - y;\r\n            var pos = this.getScaleInfo(this.width/2+x+__calculated_x, this.height/2+__calculated_y,0,0);\r\n            var c = this.context.getImageData(pos.x, pos.y, 1, 1).data;\r\n            return this.rgbToHex(c[0],c[1],c[2]);\r\n        },\r\n        changeColorInImage: function (img,find,replace) {\r\n            try{\r\n                var cvs = document.createElement(\"canvas\");\r\n                var ctx = cvs.getContext(\"2d\");\r\n                cvs.width = img.width;\r\n                cvs.height = img.height;\r\n                ctx.drawImage(img,0,0,cvs.width,cvs.height);\r\n                var rgbFind = this.hexToRgb(find);\r\n                var rgbReplace = this.hexToRgb(replace);\r\n                var imgdata = ctx.getImageData(0,0,cvs.width,cvs.height);\r\n                var imageData = imgdata.data;\r\n                for (let i = 0; i < imageData.length; i += 4) {\r\n                    var r = imageData[i];\r\n                    var g = imageData[i+1];\r\n                    var b = imageData[i+2];\r\n                    if (rgbFind.r = r && rgbFind.g == g && rgbFind.b == b) {\r\n                        //found an match!\r\n                        imageData[i] = rgbReplace.r;\r\n                        imageData[i+1] = rgbReplace.g;\r\n                        imageData[i+2] = rgbReplace.b;\r\n                    }\r\n                }\r\n                ctx.putImageData(imgdata,0,0);\r\n                return cvs.toDataURL();\r\n            }catch(e){console.error(e);}\r\n        },\r\n        changeColorsInImage: function (img,findreplaceArray) {\r\n            try{\r\n                var cvs = document.createElement(\"canvas\");\r\n                var ctx = cvs.getContext(\"2d\");\r\n                cvs.width = img.width;\r\n                cvs.height = img.height;\r\n                ctx.drawImage(img,0,0,cvs.width,cvs.height);\r\n                var imgdata = ctx.getImageData(0,0,cvs.width,cvs.height);\r\n                var imageData = imgdata.data;\r\n                for (var index2 = 0; index2 < findreplaceArray.length; index2 += 2) {\r\n                    var rgbFind = this.hexToRgb(findreplaceArray[index2]);\r\n                    var rgbReplace = this.hexToRgb(findreplaceArray[index2+1]);\r\n    \r\n                    for (var i = 0; i < imageData.length; i += 4) {\r\n                        var r = imageData[i];\r\n                        var g = imageData[i+1];\r\n                        var b = imageData[i+2];\r\n                        if (rgbFind.r = r && rgbFind.g == g && rgbFind.b == b) {\r\n                            //found an match!\r\n                            imageData[i] = rgbReplace.r;\r\n                            imageData[i+1] = rgbReplace.g;\r\n                            imageData[i+2] = rgbReplace.b;\r\n                        }\r\n                    }\r\n                }\r\n    \r\n                ctx.putImageData(imgdata,0,0);\r\n                return cvs.toDataURL();\r\n            }catch(e){console.error(e);}\r\n        }\r\n    };\r\n    renderer.camcontext = renderer.camcanvas.getContext(\"2d\");\r\n    setInterval(() => {\r\n        if (renderer.camrun) {\r\n            renderer.camvid.play(); //start the recording!\r\n            renderer.camvid.volume = 0; //do not echo!\r\n            renderer.camcanvas.width = renderer.camvid.videoWidth;\r\n            renderer.camcanvas.height = renderer.camvid.videoHeight;\r\n        } else {\r\n            renderer.camvid.pause(); //stop the recording\r\n        }\r\n    },10)\r\n    \n    return module;\n})();",
   "name": "src\\ggm2\\ggm-vm\\renderer.js",
   "dirname": "src_ggm2_ggm-vm_renderer.js",
   "realdir": "src_ggm2_ggm-vm_renderer.js",
   "realdirNoReplacer": "src\\ggm2\\ggm-vm\\renderer.js",
   "uncompileddata": "var console = require(\"log\");\r\nwindow.renderer = {\r\n\tcanvas: null,\r\n\tbg: document.createElement(\"img\"),\r\n\tbackgroundImg:null,\r\n\tgetUserMedia: function (a) {\r\n\t    return new Promise((resolve, reject) => {\r\n\t        navigator.getUserMedia(a, resolve, ()=>{resolve(\"CamDenied\");});\r\n\t    });\r\n\t},\r\n\tcamcanvas:document.createElement(\"canvas\"),\r\n\tcamcontext:null,\r\n\tcamvid:document.createElement(\"video\"),\r\n\tcamrun:false,\r\n\tstartCameraStream: async function () {\r\n\t\tif (!(this.camrun)) {\r\n\t\t\t//not to creep out the user from thinking that they are trying to get spyed on...\r\n\t\t\tvar stream = await this.getUserMedia({\r\n\t\t\t\tvideo: true,\r\n\t\t\t\taudio: true\r\n\t\t\t});\r\n\t\t\tif (stream == \"CamDenied\") {\r\n\t\t\t\treturn; //denied access (do they think that they are trying to get spyed on?)\r\n\t\t\t}\r\n\t\t\t//ok! we got access, so now we need to use it!\r\n\t\t\tthis.camstream = stream;\r\n\t\t\tthis.camvid.srcObject = stream;\r\n\t\t\tthis.camcanvas.width = this.camvid.width;\r\n\t\t\tthis.camcanvas.height = this.camvid.width;\r\n\t\t\tthis.camrun = true;\r\n\t\t\tvar audioContext = window.vm.audioEngine.context;\r\n\t\t\tvar analyser = audioContext.createAnalyser();\r\n\t\t\tvar microphone = audioContext.createMediaStreamSource(stream);\r\n\r\n\t\t\tanalyser.smoothingTimeConstant = 0.8;\r\n\t\t\tanalyser.fftSize = 1024;\r\n\t\t\tvar rend = this;\r\n\t\t\tmicrophone.connect(analyser);\r\n\t\t\tthis.caminterval = setInterval(function () {\r\n\t\t\t\tvar array = new Uint8Array(analyser.frequencyBinCount);\r\n\t\t\t\tanalyser.getByteFrequencyData(array);\r\n\t\t\t\tvar arraySum = array.reduce((a, value) => a + value, 0);\r\n\t\t\t\tvar average = arraySum / array.length;\r\n\t\t\t\trend.micvol = average/200*100;\r\n\t\t\t\t// colorPids(average);\r\n\t\t\t},1);\r\n\t\t}\r\n\t},\r\n\tstopCameraStream: async function () {\r\n\t\t//quick check to see if we are running the camrea\r\n\t\tif (this.camrun) {\r\n\t\t\tthis.camrun = false; //stop rendering the camrea!\r\n\t\t\t//stop recording video!\r\n\t\t\trenderer.camstream.getVideoTracks().forEach((t) => {\r\n\t\t\t\tt.stop();\r\n\t\t\t});\r\n\t\t\t//stop recording audio!\r\n\t\t\trenderer.camstream.getAudioTracks().forEach((t) => {\r\n\t\t\t\tt.stop();\r\n\t\t\t});\r\n\t\t\t//end video!\r\n\t\t\tthis.camvid.pause();\r\n\t\t\tthis.camvid.srcObject = null;\r\n\t\t\tthis.camstream = null;\r\n\t\t\tclearInterval(this.caminterval);\r\n\t\t}\r\n\t},\r\n\tstart: function () {\r\n\t\tthis.context = this.canvas.getContext(\"2d\");\r\n\t\tthis.context.globalAlpha = 1;\r\n\t\tthis.context.strokeStyle = this.color;\r\n\t\tthis.context.fillStyle = this.color;\r\n\t\tthis.context.beginPath();\r\n\t\tthis.context.fillRect(0, 0, this.canvas.width + 2, this.canvas.height + 2);\r\n\t\tthis.context.stroke();\r\n\t\tthis.test=0;\r\n\t\tthis.canvas.style.imageRendering = \"Pixelated\";\r\n\t},\r\n\tcamghost: 0,\r\n\ttick: function (sprites,monitors) {\r\n\t\tthis.events.tick.forEach((funct) => {\r\n\t\t\ttry{\r\n\t\t\t\tfunct();\r\n\t\t\t}catch(e){console.error(\"renderer ran event, but an error was thrown.\",e)}\r\n\t\t});\r\n\t\tthis.context.globalAlpha = 1;\r\n\t\tthis.context.fillStyle = this.color;\r\n\t\tthis.context.strokeStyle = this.color;\r\n\t\tthis.context.beginPath();\r\n\t\tthis.context.fillRect(0, 0, this.canvas.width + 2, this.canvas.height + 2);\r\n\t\tthis.context.stroke();\r\n\t\tthis.context.webkitImageSmoothingEnabled = false;\r\n\t\tthis.context.mozImageSmoothingEnabled = false;\r\n\t\tthis.context.imageSmoothingEnabled = false;\r\n\t\tif (this.camrun) {\r\n\t\t\tthis.camcontext.globalAlpha = 1;\r\n\t\t\tthis.camcontext.drawImage(this.camvid,0,0,this.camcanvas.width,this.camcanvas.height);\r\n\t\t\tthis.context.globalAlpha = 1 - (this.camghost / 100);\r\n\t\t\tthis.context.drawImage(this.camvid,0,0,this.canvas.width,this.canvas.height);\r\n\t\t\tthis.context.globalAlpha = 1;\r\n\t\t}\r\n\t\ttry{\r\n\t\t\tthis.context.drawImage(this.bg,0,0,this.canvas.width,this.canvas.height);\r\n\t\t}catch(e){}\r\n\t\tfor (var i in sprites) {\r\n\t\t\tsprites[i];\r\n\t\t\tthis._drawSprite(sprites[i]);\r\n\t\t}\r\n\t\tfor (var i in monitors) {\r\n\t\t\tmonitors[i];\r\n\t\t\tthis._drawMonitor(monitors[i]);\r\n\t\t}\r\n\t\tthis.events.ticked.forEach((funct) => {\r\n\t\t\ttry{\r\n\t\t\t\tfunct();\r\n\t\t\t}catch(e){console.error(\"renderer ran event, but an error was thrown.\",e)}\r\n\t\t});\r\n\t},\r\n\tevents:{\r\n\t\tbeforedraw:[],\r\n\t\tafterdraw:[],\r\n\t\tdrawsprite:[],\r\n\t\tbeforemonitordraw:[],\r\n\t\taftermonitordraw:[],\r\n\t\ttick:[],\r\n\t\tticked:[]\r\n\t},\r\n\taddEventListener: function (name,funct) {\r\n\t\tif (this.events[name.toLowerCase()]) {\r\n\t\t\tthis.events[name.toLowerCase()].push(funct);\r\n\t\t} else {\r\n\t\t\tconsole.warn(\"renderer tried adding event \\\"\"+name+\"\\\" but cant find it. check the spelling and try again.\");\r\n\t\t}\r\n\t},\r\n\twidth:600,\r\n\theight:360,\r\n\tgetScaleInfo: function (x,y,width,height) {\r\n\t\tvar sw = this.canvas.width/this.width;\r\n\t\tvar sh = this.canvas.height/this.height;\r\n\t\treturn {\r\n\t\t\tx:Math.round(sw*x),\r\n\t\t\ty:Math.round(sh*y),\r\n\t\t\tw:Math.round(sw*width),\r\n\t\t\th:Math.round(sh*height),\r\n\t\t\tscalewidth:sw,\r\n\t\t\tscaleheight:sh\r\n\t\t};\r\n\t},\r\n\tdrawImage: function (img,x,y,w,h) {\r\n\t\tvar si = this.getScaleInfo(x,y,w,h);\r\n\t\tthis.context.drawImage(img,si.x,si.y,si.w,si.h);\r\n\t},\r\n\ttranslate: function (x,y) {\r\n\t\tvar si = this.getScaleInfo(x,y,0,0);\r\n\t\tthis.context.translate(si.x,si.y);\r\n\t},\r\n\t_drawSprite: function (json) {\r\n\t\tthis.events.beforedraw.forEach((funct) => {\r\n\t\t\ttry{\r\n\t\t\t\tfunct();\r\n\t\t\t}catch(e){console.error(\"renderer ran event, but an error was thrown.\",e)}\r\n\t\t});\r\n\t\tthis.context.save();\r\n\t\t//use the try to not throw an error when renderering failed, so the renderer keeps ticking.\r\n\t\ttry{\r\n\t\t\tthis.events.drawsprite.forEach((funct) => {\r\n\t\t\t\ttry{\r\n\t\t\t\t\tfunct(json);\r\n\t\t\t\t}catch(e){console.error(\"renderer ran event, but an error was thrown.\",e)}\r\n\t\t\t});\r\n\t\t\tvar __calculated_x = json.x;\r\n\t\t\tvar __calculated_y = 0 - json.y;\r\n\t\t\tvar ghost = json.ghost;\r\n\t\t\tif (ghost > 100) {\r\n\t\t\t\tghost = 100;\r\n\t\t\t}\r\n\t\t\tif (ghost < 0) {\r\n\t\t\t\tghost = 0;\r\n\t\t\t}\r\n\t\t\tthis.context.globalAlpha = 1 - (ghost / 100);\r\n\t\t\t//this.context.translate(this.canvas.width/2+json.x+__calculated_x, this.canvas.height/2+__calculated_y);\r\n\t\t\tthis.translate(this.width/2+json.x+__calculated_x, this.height/2+__calculated_y); //this moves the image to the sprite position.\r\n\t\t\tthis.context.rotate((json.direction - 90)*Math.PI/180);\r\n\t\t\tif (json.flip == \"hor\") {\r\n\t\t\t\tthis.context.scale(-1,1);\r\n\t\t\t} else {\r\n\t\t\t\tif (json.flip == \"ver\") {\r\n\t\t\t\t\tthis.context.scale(1,-1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.drawImage(json.image, json.width/-2, json.height/-2, json.width, json.height); //draw the image and offset it so it rotates in the center.\r\n\t\t}catch(e){}\r\n\t\tthis.context.restore();\r\n\t\tthis.events.afterdraw.forEach((funct) => {\r\n\t\t\ttry{\r\n\t\t\t\tfunct();\r\n\t\t\t}catch(e){console.error(\"renderer ran event, but an error was thrown.\",e)}\r\n\t\t});\r\n\t},\r\n\t_drawMonitor: function (json) {\r\n\t\t//Scale Update!!\r\n\t\t//this also fixes some bugs when rendering vars\r\n\t\tthis.events.beforemonitordraw.forEach((funct) => {\r\n\t\t\ttry{\r\n\t\t\t\tfunct();\r\n\t\t\t}catch(e){console.error(\"renderer ran event, but an error was thrown.\",e)}\r\n\t\t});\r\n\t\tthis.context.save();\r\n\t\t//use the try to not throw an error when renderering failed, so the renderer keeps ticking.\r\n\t\ttry{\r\n\t\t\tif (json.visible) {\r\n\t\t\t\tthis.context.globalAlpha = 1;\r\n\t\t\t\tthis.context.translate(0,0);\r\n\t\t\t\tvar textscale = this.getScaleInfo().scalewidth;\r\n\t\t\t\trenderer.context.font = 'bold '+(15*this.getScaleInfo().scalewidth)+'px arial';\r\n\t\t\t\tvar textWidth = renderer.context.measureText(json.value).width/textscale;\r\n\t\t\t\tvar textNameWidth = renderer.context.measureText(json.name).width/textscale;\r\n\t\t\t\tthis.context.globalAlpha = 1;\r\n\t\t\t\trenderer.context.fillStyle = \"#868e96\";\r\n\t\t\t\trenderer.fillRect(Math.round(json.x-2),Math.round(json.y-2),Math.round(24+textNameWidth+textWidth),Math.round(24));\r\n\t\t\t\trenderer.context.fillStyle = \"#ced4da\";\r\n\t\t\t\trenderer.fillRect(Math.round(json.x),Math.round(json.y),Math.round(20+textNameWidth+textWidth),Math.round(20));\t\r\n\t\t\t\trenderer.context.fillStyle = \"#ff8c00\";\r\n\t\t\t\trenderer.fillRect(Math.round(json.x+textNameWidth+10),Math.round(json.y+3),Math.round(5+textWidth),Math.round(15));\r\n\t\t\t\trenderer.context.fillStyle = \"white\";\r\n\t\t\t\trenderer.fillText(json.value, Math.round(json.x+textNameWidth+12),Math.round(json.y + 16));\r\n\t\t\t\trenderer.context.fillStyle = \"black\";\r\n\t\t\t\trenderer.fillText(json.name, Math.round(json.x + 6),Math.round(json.y + 15));\r\n\t\t\t\treturn {\r\n\t\t\t\t\twidth:Math.round(74+textNameWidth+textWidth),\r\n\t\t\t\t\theight:Math.round(24),\r\n\t\t\t\t\tx:Math.round(json.x),\r\n\t\t\t\t\ty:Math.round(json.y)\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t}catch(e){console.error(e);}\r\n\t\tthis.context.restore();\r\n\t\tthis.events.aftermonitordraw.forEach((funct) => {\r\n\t\t\ttry{\r\n\t\t\t\tfunct();\r\n\t\t\t}catch(e){console.error(\"renderer ran event, but an error was thrown.\",e)}\r\n\t\t});\r\n\t},\r\n\tfillRect: function (x,y,w,h) {\r\n\t\tvar si = this.getScaleInfo(x,y,w,h);\r\n\t\tthis.context.fillRect(Math.round(si.x),Math.round(si.y),Math.round(si.w),Math.round(si.h));\r\n\t},\r\n\tfillText: function (txt,x,y) {\r\n\t\tvar si = this.getScaleInfo(x,y,0,0);\r\n\t\tthis.context.fillText(txt,Math.round(si.x),Math.round(si.y));\r\n\t},\r\n\tcolor:\"#ffffff\",\r\n\tgetColorEffect: function (img,r,g,b) {\r\n\t\ttry{\r\n\t\t\tvar cvs = document.createElement(\"canvas\");\r\n\t\t\tvar ctx = cvs.getContext(\"2d\");\r\n\t\t\tcvs.width = img.width;\r\n\t\t\tcvs.height = img.height;\r\n\t\t\tctx.drawImage(img,0,0,cvs.width,cvs.height);\r\n\t\t\tvar imgdata = ctx.getImageData(0,0,cvs.width,cvs.height);\r\n\t\t\tvar imageData = imgdata.data;\r\n\t\t\tfor (let i = 0; i < imageData.length; i += 4) {\r\n\t\t\t\timageData[i] += r;\r\n\t\t\t\timageData[i+1] += g;\r\n\t\t\t\timageData[i+2] += g;\r\n\t\t\t}\r\n\t\t\tctx.putImageData(imgdata,0,0);\r\n\t\t\treturn cvs.toDataURL();\r\n\t\t}catch(e){console.error(e);}\r\n\t},\r\n\tgetRandomColorEffect: function (img,randomness) {\r\n\t\ttry{\r\n\t\t\tvar cvs = document.createElement(\"canvas\");\r\n\t\t\tvar ctx = cvs.getContext(\"2d\");\r\n\t\t\tcvs.width = img.width;\r\n\t\t\tcvs.height = img.height;\r\n\t\t\tctx.drawImage(img,0,0,cvs.width,cvs.height);\r\n\t\t\tvar imgdata = ctx.getImageData(0,0,cvs.width,cvs.height);\r\n\t\t\tvar imageData = imgdata.data;\r\n\t\t\tfor (let i = 0; i < imageData.length; i += 4) {\r\n\t\t\t\timageData[i] += Math.random()*randomness;\r\n\t\t\t\timageData[i+1] += Math.random()*randomness;\r\n\t\t\t\timageData[i+2] += Math.random()*randomness;\r\n\t\t\t}\r\n\t\t\tctx.putImageData(imgdata,0,0);\r\n\t\t\treturn cvs.toDataURL();\r\n\t\t}catch(e){console.error(e);}\r\n\t},\r\n\tgetGlitchColorEffect: function (img,randomness) {\r\n\t\ttry{\r\n\t\t\tvar cvs = document.createElement(\"canvas\");\r\n\t\t\tvar ctx = cvs.getContext(\"2d\");\r\n\t\t\tcvs.width = img.width;\r\n\t\t\tcvs.height = img.height;\r\n\t\t\tctx.drawImage(img,0,0,cvs.width,cvs.height);\r\n\t\t\tvar imgdata = ctx.getImageData(0,0,cvs.width,cvs.height);\r\n\t\t\tvar imageData = imgdata.data;\r\n\t\t\tfor (let i = 0; i < imageData.length; i += 4) {\r\n\t\t\t\timageData[i] = Math.random()*randomness;\r\n\t\t\t\timageData[i+1] = Math.random()*randomness;\r\n\t\t\t\timageData[i+2] = Math.random()*randomness;\r\n\t\t\t}\r\n\t\t\tctx.putImageData(imgdata,0,0);\r\n\t\t\treturn cvs.toDataURL();\r\n\t\t}catch(e){console.error(e);}\r\n\t},\r\n\tgetInvertColorEffect: function (img) {\r\n\t\ttry{\r\n\t\t\tvar cvs = document.createElement(\"canvas\");\r\n\t\t\tvar ctx = cvs.getContext(\"2d\");\r\n\t\t\tcvs.width = img.width;\r\n\t\t\tcvs.height = img.height;\r\n\t\t\tctx.drawImage(img,0,0,cvs.width,cvs.height);\r\n\t\t\tvar imgdata = ctx.getImageData(0,0,cvs.width,cvs.height);\r\n\t\t\tvar imageData = imgdata.data;\r\n\t\t\tfor (let i = 0; i < imageData.length; i += 4) {\r\n\t\t\t\tvar r = imageData[i];\r\n\t\t\t\tvar g = imageData[i+1];\r\n\t\t\t\tvar b = imageData[i+2];\r\n\t\t\t\timageData[i] = b;\r\n\t\t\t\timageData[i+1] = g;\r\n\t\t\t\timageData[i+2] = r;\r\n\t\t\t}\r\n\t\t\tctx.putImageData(imgdata,0,0);\r\n\t\t\treturn cvs.toDataURL();\r\n\t\t}catch(e){console.error(e);}\r\n\t},\r\n\tgetInvertColorEffect: function (img) {\r\n\t\ttry{\r\n\t\t\tvar cvs = document.createElement(\"canvas\");\r\n\t\t\tvar ctx = cvs.getContext(\"2d\");\r\n\t\t\tcvs.width = img.width;\r\n\t\t\tcvs.height = img.height;\r\n\t\t\tctx.drawImage(img,0,0,cvs.width,cvs.height);\r\n\t\t\tvar imgdata = ctx.getImageData(0,0,cvs.width,cvs.height);\r\n\t\t\tvar imageData = imgdata.data;\r\n\t\t\tfor (let i = 0; i < imageData.length; i += 4) {\r\n\t\t\t\tvar r = imageData[i];\r\n\t\t\t\tvar g = imageData[i+1];\r\n\t\t\t\tvar b = imageData[i+2];\r\n\t\t\t\timageData[i] = b;\r\n\t\t\t\timageData[i+1] = g;\r\n\t\t\t\timageData[i+2] = r;\r\n\t\t\t}\r\n\t\t\tctx.putImageData(imgdata,0,0);\r\n\t\t\treturn cvs.toDataURL();\r\n\t\t}catch(e){console.error(e);}\r\n\t},\r\n\tcomponentToHex:function (c) {\r\n\t  var hex = c.toString(16);\r\n\t  return hex.length == 1 ? \"0\" + hex : hex;\r\n\t},\r\n\trgbToHex:function (r, g, b) {\r\n\t  return \"#\" + this.componentToHex(r) + this.componentToHex(g) + this.componentToHex(b);\r\n\t},\r\n\thexToRgb:function (hex) {\r\n\t    var result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\r\n\t    return result ? {\r\n\t        r: parseInt(result[1], 16),\r\n\t        g: parseInt(result[2], 16),\r\n\t        b: parseInt(result[3], 16)\r\n\t    }\r\n\t     : null;\r\n\t},\r\n\tgetColorAtPos: function (x,y) {\r\n\t\tvar __calculated_x = x;\r\n\t\tvar __calculated_y = 0 - y;\r\n\t\tvar pos = this.getScaleInfo(this.width/2+x+__calculated_x, this.height/2+__calculated_y,0,0);\r\n\t\tvar c = this.context.getImageData(pos.x, pos.y, 1, 1).data;\r\n\t\treturn this.rgbToHex(c[0],c[1],c[2]);\r\n\t},\r\n\tchangeColorInImage: function (img,find,replace) {\r\n\t\ttry{\r\n\t\t\tvar cvs = document.createElement(\"canvas\");\r\n\t\t\tvar ctx = cvs.getContext(\"2d\");\r\n\t\t\tcvs.width = img.width;\r\n\t\t\tcvs.height = img.height;\r\n\t\t\tctx.drawImage(img,0,0,cvs.width,cvs.height);\r\n\t\t\tvar rgbFind = this.hexToRgb(find);\r\n\t\t\tvar rgbReplace = this.hexToRgb(replace);\r\n\t\t\tvar imgdata = ctx.getImageData(0,0,cvs.width,cvs.height);\r\n\t\t\tvar imageData = imgdata.data;\r\n\t\t\tfor (let i = 0; i < imageData.length; i += 4) {\r\n\t\t\t\tvar r = imageData[i];\r\n\t\t\t\tvar g = imageData[i+1];\r\n\t\t\t\tvar b = imageData[i+2];\r\n\t\t\t\tif (rgbFind.r = r && rgbFind.g == g && rgbFind.b == b) {\r\n\t\t\t\t\t//found an match!\r\n\t\t\t\t\timageData[i] = rgbReplace.r;\r\n\t\t\t\t\timageData[i+1] = rgbReplace.g;\r\n\t\t\t\t\timageData[i+2] = rgbReplace.b;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tctx.putImageData(imgdata,0,0);\r\n\t\t\treturn cvs.toDataURL();\r\n\t\t}catch(e){console.error(e);}\r\n\t},\r\n\tchangeColorsInImage: function (img,findreplaceArray) {\r\n\t\ttry{\r\n\t\t\tvar cvs = document.createElement(\"canvas\");\r\n\t\t\tvar ctx = cvs.getContext(\"2d\");\r\n\t\t\tcvs.width = img.width;\r\n\t\t\tcvs.height = img.height;\r\n\t\t\tctx.drawImage(img,0,0,cvs.width,cvs.height);\r\n\t\t\tvar imgdata = ctx.getImageData(0,0,cvs.width,cvs.height);\r\n\t\t\tvar imageData = imgdata.data;\r\n\t\t\tfor (var index2 = 0; index2 < findreplaceArray.length; index2 += 2) {\r\n\t\t\t\tvar rgbFind = this.hexToRgb(findreplaceArray[index2]);\r\n\t\t\t\tvar rgbReplace = this.hexToRgb(findreplaceArray[index2+1]);\r\n\r\n\t\t\t\tfor (var i = 0; i < imageData.length; i += 4) {\r\n\t\t\t\t\tvar r = imageData[i];\r\n\t\t\t\t\tvar g = imageData[i+1];\r\n\t\t\t\t\tvar b = imageData[i+2];\r\n\t\t\t\t\tif (rgbFind.r = r && rgbFind.g == g && rgbFind.b == b) {\r\n\t\t\t\t\t\t//found an match!\r\n\t\t\t\t\t\timageData[i] = rgbReplace.r;\r\n\t\t\t\t\t\timageData[i+1] = rgbReplace.g;\r\n\t\t\t\t\t\timageData[i+2] = rgbReplace.b;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tctx.putImageData(imgdata,0,0);\r\n\t\t\treturn cvs.toDataURL();\r\n\t\t}catch(e){console.error(e);}\r\n\t}\r\n};\r\nrenderer.camcontext = renderer.camcanvas.getContext(\"2d\");\r\nsetInterval(() => {\r\n\tif (renderer.camrun) {\r\n\t\trenderer.camvid.play(); //start the recording!\r\n\t\trenderer.camvid.volume = 0; //do not echo!\r\n\t\trenderer.camcanvas.width = renderer.camvid.videoWidth;\r\n\t\trenderer.camcanvas.height = renderer.camvid.videoHeight;\r\n\t} else {\r\n\t\trenderer.camvid.pause(); //stop the recording\r\n\t}\r\n},10)\r\n"
  },
  "src_ggm2_ggm-vm_variables.js": {
   "data": "(function () {\n//ignore these variables, for the module stuff.\n    var module = {exports:null,filename:JSON.stringify(name)};\n    var require = function (a) {return gp_require(a,\"src\\\\ggm2\\\\ggm-vm\\\\variables.js\");};\n    var var__gvbvdxx_pack_filedata = null; //prevent overwrite\n    var cur_file = \"src\\\\ggm2\\\\ggm-vm\\\\variables.js\";\n    \n    return module;\n})();",
   "name": "src\\ggm2\\ggm-vm\\variables.js",
   "dirname": "src_ggm2_ggm-vm_variables.js",
   "realdir": "src_ggm2_ggm-vm_variables.js",
   "realdirNoReplacer": "src\\ggm2\\ggm-vm\\variables.js",
   "uncompileddata": ""
  }
 },
 "files": [
  {
   "data": "(function () {\n//ignore these variables, for the module stuff.\n    var module = {exports:null,filename:JSON.stringify(name)};\n    var require = function (a) {return gp_require(a,\"./src/usevm.js\");};\n    var var__gvbvdxx_pack_filedata = null; //prevent overwrite\n    var cur_file = \"./src/usevm.js\";\n    module.exports = true;\n    return module;\n})();",
   "name": "./src/usevm.js",
   "dirname": "src_usevm.js",
   "realdir": "src_usevm.js",
   "realdirNoReplacer": "src\\usevm.js",
   "uncompileddata": "module.exports = true;"
  },
  {
   "data": "(function () {\n//ignore these variables, for the module stuff.\n    var module = {exports:null,filename:JSON.stringify(name)};\n    var require = function (a) {return gp_require(a,\"./src/index.js\");};\n    var var__gvbvdxx_pack_filedata = null; //prevent overwrite\n    var cur_file = \"./src/index.js\";\n    /*\r\n    Uncomment this if you want cloud variables\r\n    \r\n    \r\n    window.cloudsetup = {\r\n        ws:\"ws://localhost:4726\", //websocket url\r\n        id:12345 //connection id, to separate cloud messages from others\r\n    };\r\n    */\r\n    \r\n    window.useBlocklyBlocks = false; //change this to true to have more blocks (from blockly)\r\n    window.useConfirmDialog = true; //asks the user if they want to save their changes (if true)\r\n    \r\n    //this here loads everything.\r\n    var usevm = require(\"src/usevm.js\");\r\n    var ggm2path = require(\"src/paths.js\");\r\n    if (usevm) {\r\n        function doScriptAdd(s) {\r\n            return require(\"src/\" + ggm2path + \"/\" + s);\r\n        }\r\n        doScriptAdd(\"ggm-vm/index.js\");\r\n        doScriptAdd(\"ggm-vm/renderer.js\");\r\n        doScriptAdd(\"ggm-vm/audio.js\");\r\n        doScriptAdd(\"ggm-vm/better-audio-ctx.js\");\r\n    } else {\r\n        require(\"src/\"+ggm2path+\"/ggm-gui/main.js\");\r\n    }\n    return module;\n})();",
   "name": "./src/index.js",
   "dirname": "src_index.js",
   "realdir": "src_index.js",
   "realdirNoReplacer": "src\\index.js",
   "uncompileddata": "/*\r\nUncomment this if you want cloud variables\r\n\r\n\r\nwindow.cloudsetup = {\r\n\tws:\"ws://localhost:4726\", //websocket url\r\n\tid:12345 //connection id, to separate cloud messages from others\r\n};\r\n*/\r\n\r\nwindow.useBlocklyBlocks = false; //change this to true to have more blocks (from blockly)\r\nwindow.useConfirmDialog = true; //asks the user if they want to save their changes (if true)\r\n\r\n//this here loads everything.\r\nvar usevm = require(\"src/usevm.js\");\r\nvar ggm2path = require(\"src/paths.js\");\r\nif (usevm) {\r\n\tfunction doScriptAdd(s) {\r\n\t\treturn require(\"src/\" + ggm2path + \"/\" + s);\r\n\t}\r\n\tdoScriptAdd(\"ggm-vm/index.js\");\r\n\tdoScriptAdd(\"ggm-vm/renderer.js\");\r\n\tdoScriptAdd(\"ggm-vm/audio.js\");\r\n\tdoScriptAdd(\"ggm-vm/better-audio-ctx.js\");\r\n} else {\r\n\trequire(\"src/\"+ggm2path+\"/ggm-gui/main.js\");\r\n}"
  },
  {
   "data": "(function () {\n//ignore these variables, for the module stuff.\n    var module = {exports:null,filename:JSON.stringify(name)};\n    var require = function (a) {return gp_require(a,\"./src/paths.js\");};\n    var var__gvbvdxx_pack_filedata = null; //prevent overwrite\n    var cur_file = \"./src/paths.js\";\n    //path for ggm2\r\n    module.exports = \"ggm2\";\r\n    \n    return module;\n})();",
   "name": "./src/paths.js",
   "dirname": "src_paths.js",
   "realdir": "src_paths.js",
   "realdirNoReplacer": "src\\paths.js",
   "uncompileddata": "//path for ggm2\r\nmodule.exports = \"ggm2\";\r\n"
  },
  {
   "data": "(function () {\n//ignore these variables, for the module stuff.\n    var module = {exports:null,filename:JSON.stringify(name)};\n    var require = function (a) {return gp_require(a,\"src\\\\ggm2\\\\ggm-vm\\\\audio.js\");};\n    var var__gvbvdxx_pack_filedata = null; //prevent overwrite\n    var cur_file = \"src\\\\ggm2\\\\ggm-vm\\\\audio.js\";\n    window.audioEngine = {\r\n        addToPreload: async function (url) {\r\n            var request = await fetch(url);\r\n            var data = await request.arrayBuffer();\r\n            window.audioEngine.audPreload[url] = window.audioEngine.copyArrayBuffer(window.audioEngine.audPreload[url]);\r\n        },\r\n        audPreload: {},\r\n        copyArrayBuffer: function (src)  {\r\n            var dst = new ArrayBuffer(src.byteLength);\r\n            new Uint8Array(dst).set(new Uint8Array(src));\r\n            return dst;\r\n        },\r\n        sfx:{\r\n            audio:null,\r\n            audioelements:[],\r\n            play:async function (a) {\r\n                /**\r\n                Bug Fix!\r\n                \r\n                fixed the audio bug when playing mutiple sounds, including long ones,\r\n                making it imposible to stop in desktop app.\r\n                \r\n                */\r\n                window.audioEngine.audioRunning = true;\r\n                if (!(window.audioEngine.audPreload[a])) {\r\n                    var request = await fetch(a);\r\n                    var data = await request.arrayBuffer();\r\n                    window.audioEngine.audPreload[a] = window.audioEngine.copyArrayBuffer(data);\r\n                } else {\r\n                    var data = window.audioEngine.copyArrayBuffer(window.audioEngine.audPreload[a]);\r\n                }\r\n                var audioBuffer = await window.audioEngine.decodeAudioDataAsync(data);\r\n                var source = window.audioEngine.context.createBufferSource();\r\n                if (window.audioEngine.audioRunning) {\r\n                    source.buffer = audioBuffer;\r\n                    this.source = source;\r\n                    \r\n                    source.connect(window.audioEngine.context.destination);\r\n                    source.loop = false;\r\n                    source.start();\r\n                    window.audioEngine.sources.push(source);\r\n                    source.onended = function () {\r\n                        var dat = [];\r\n                        for (var obj of window.audioEngine.sources) {\r\n                            if (!(obj == source)) {\r\n                                dat.push(obj);\r\n                            }\r\n                        }\r\n                        window.audioEngine.sources = dat;\r\n                    };\r\n                }\r\n    /*             //bug pach starts here\r\n                this.audio.onended = function () {\r\n                    delete audioEngine.sfx.audioelements.indexOf(this.audio);\r\n                    var allSfx = [];\r\n                    for (var i in audioEngine.sfx.audioelements) {\r\n                        if (audioEngine.sfx.audioelements) {\r\n                            allSfx.push(audioEngine.sfx.audioelements[i]);\r\n                        }\r\n                    }\r\n                    audioEngine.sfx.audioelements = allSfx;\r\n                }; */\r\n            }\r\n        },\r\n        decodeAudioDataAsync: (data) => {\r\n            return new Promise((resolve,reject) => {\r\n                window.audioEngine.context.decodeAudioData(data,resolve,reject);\r\n            })\r\n        },\r\n        sources: [\r\n        \r\n        ],\r\n        audioRunning:false,\r\n        bgm:{\r\n            audio:{src:\"\"},\r\n            isPlaying:false,\r\n            running:false,\r\n            stopRunningSource: () => {\r\n                if (this.source) {\r\n                    try{\r\n                        this.source.stop();\r\n                    }catch(e){}\r\n                }\r\n            },\r\n            play:async function () {\r\n                try{\r\n                    this.running = true;\r\n                    this.isPlaying = false;\r\n                    this.stopRunningSource();\r\n                    var source = window.audioEngine.context.createBufferSource();\r\n                    window.audioEngine.sources.push(source);\r\n                    window.audioEngine.audioRunning = true;\r\n                    if (!(window.audioEngine.audPreload[this.audio.src])) {\r\n                        this.stopRunningSource();\r\n                        var request = await fetch(this.audio.src);\r\n                        this.stopRunningSource();\r\n                        this.isPlaying = false;\r\n                        this.stopRunningSource();\r\n                        var data = await request.arrayBuffer();\r\n                        this.stopRunningSource();\r\n                        this.isPlaying = false;\r\n                        window.audioEngine.audPreload[this.audio.src] = window.audioEngine.copyArrayBuffer(data);\r\n                    } else {\r\n                        this.isPlaying = false;\r\n                        this.stopRunningSource();\r\n                        var data = window.audioEngine.copyArrayBuffer(window.audioEngine.audPreload[this.audio.src]);\r\n                        this.isPlaying = false;\r\n                        this.stopRunningSource();\r\n                    }\r\n                    this.isPlaying = false;\r\n                    this.stopRunningSource();\r\n                    var audioBuffer = await window.audioEngine.decodeAudioDataAsync(data);\r\n                    this.stopRunningSource();\r\n                    this.isPlaying = false;\r\n                    source.buffer = audioBuffer;\r\n                    this.isPlaying = false;\r\n                    source.connect(window.audioEngine.context.destination);\r\n                    source.loop = true;\r\n                    this.isPlaying = false;\r\n                    if (this.source) {\r\n                        try{\r\n                            this.source.stop();\r\n                        }catch(e){}\r\n                    }\r\n                    this.source = source;\r\n                    if (window.audioEngine.audioRunning) {\r\n                        if (!(this.isPlaying)) {\r\n                            this.isPlaying = true;\r\n                            source.start();\r\n                        }\r\n                    }\r\n                }catch(e){\r\n                    console.warn(\"[AudioEngine]:error ignored\" + e);\r\n                };\r\n            },\r\n            setSrc:function (a) {\r\n                this.audio.src = a;\r\n            }\r\n        },\r\n        audPreload:{\r\n            \r\n        },\r\n        stop:function () {\r\n            try{\r\n            if (this.sfx.audio) {\r\n                this.sfx.audio.pause();\r\n                this.sfx.audio = null;\r\n            }\r\n            this.bgm.running = false;\r\n            this.bgm.isPlaying = false;\r\n            this.audioRunning = false;\r\n            for (var source of this.sources) {\r\n                try{\r\n                    source.stop()\r\n                }catch(e){}\r\n            }\r\n            this.sources = [];\r\n            }catch(e){\r\n                console.warn(\"[AudioEngine]:error ignored\" + e);\r\n            };\r\n            vm.betterAudio.stopAllAudios();\r\n        },\r\n        tickAudio:function () {\r\n            //console.log(this.bgm.isPlaying);\r\n            if (window.audioEngine.bgm.isPlaying) {\r\n                //if (!(window.audioEngine.bgm.running)) {\r\n                //    window.audioEngine.bgm.play();\r\n                //}\r\n            } else {\r\n                try{\r\n                    window.audioEngine.bgm.running = false;\r\n                    window.audioEngine.bgm.source.stop();\r\n                }catch(e){}\r\n            }\r\n        }\r\n    }\r\n    window.audioEngine.bgm.audio.loop = true;\r\n    setInterval(window.audioEngine.tickAudio,1);\r\n    window.audioEngine.context = new AudioContext();\r\n    setInterval(() => {\r\n        if (!(window.audioEngine.context.state == \"running\")) {\r\n            window.audioEngine.context = new AudioContext\r\n        }\r\n    },10);\r\n    /*\r\n    the idea was to use context, but scrapped, because of more load lag and how mutch time it takes\r\n    window.audioEngine = {\r\n        context:new AudioContext(),\r\n        source: null,\r\n        sources:[],\r\n        apiGetAudio: async (audioBufferData,callback) => {\r\n          const context = window.audioEngine.context;\r\n            function copy(src)  {\r\n                var dst = new ArrayBuffer(src.byteLength);\r\n                new Uint8Array(dst).set(new Uint8Array(src));\r\n                return dst;\r\n            }\r\n          context.decodeAudioData(copy(audioBufferData),function (audioBuffer) {\r\n            window.audioEngine.source = context.createBufferSource();\r\n            var source = window.audioEngine.source\r\n            source.buffer = audioBuffer;\r\n            source.connect(context.destination);\r\n            source.start();\r\n            window.audioEngine.sources.push(source);\r\n            source.running = true;\r\n            source.onended = function () {\r\n                if (callback) {\r\n                    delete window.audioEngine.sources.indexOf(source);\r\n                    var sources = [];\r\n                    for (var i in window.audioEngine.sources) {\r\n                        if (window.audioEngine.sources[i]){\r\n                            sources.push(window.audioEngine.sources[i]);\r\n                        }\r\n                    }\r\n                    window.audioEngine.sources = sources;\r\n                    callback(source);\r\n                }\r\n            };\r\n          });\r\n        },\r\n        sfx:{\r\n            audio:null,\r\n            play:function (a) {\r\n                fetch(a).then((a) => {a.arrayBuffer().then((data) => {\r\n                    window.audioEngine.apiGetAudio(data);\r\n                })});\r\n            }\r\n        },\r\n        bgm:{\r\n            audio:\"\",\r\n            isPlaying:false,\r\n            play:function () {\r\n                console.log(\"loading audio data\")\r\n                fetch(window.audioEngine.bgm.audio).then((data1) => {data1.arrayBuffer().then((data) => {\r\n                    console.log(\"playing audio.\");\r\n                    window.audioEngine.apiGetAudio(data,function (source) {\r\n                        if (source.running) {\r\n                            window.audioEngine.bgm.play();\r\n                        }\r\n                    });\r\n                })});\r\n            },\r\n            pause:function () {\r\n                for (var i in window.audioEngine.sources) {\r\n                    try{\r\n                        window.audioEngine.sources[i].stop();\r\n                        window.audioEngine.sources[i].running = false;\r\n                    }catch(e){console.warn(`[AudioEngine]:Failed to stop audio context source: ${e}`);}\r\n                }\r\n            },\r\n            setSrc:function (a) {\r\n                window.audioEngine.bgm.audio = a;\r\n            }\r\n        },\r\n        stop:function () {\r\n            try{\r\n            this.bgm.isPlaying = false;\r\n            }catch(e){\r\n                console.warn(\"[AudioEngine]:error ignored\" + e);\r\n            };\r\n        },\r\n        tickAudio:function () {\r\n            if (window.audioEngine.bgm.isPlaying == true) {\r\n                window.audioEngine.bgm.isPlaying = false;\r\n                window.audioEngine.bgm.play();\r\n            } else {\r\n                if (window.audioEngine.bgm.isPlaying == false) {\r\n                    window.audioEngine.bgm.isPlaying = null;\r\n                    window.audioEngine.bgm.pause();\r\n                } else {\r\n                    window.audioEngine.bgm.isPlaying = null;\r\n                }\r\n            }\r\n            if (!(audioEngine.context.state == \"running\")) {\r\n                audioEngine.context = new AudioContext();\r\n            }\r\n        },\r\n        active:false\r\n    }\r\n    window.audioEngine.bgm.audio.loop = true;\r\n    setInterval(window.audioEngine.tickAudio,1);*/\n    return module;\n})();",
   "name": "src\\ggm2\\ggm-vm\\audio.js",
   "dirname": "src_ggm2_ggm-vm_audio.js",
   "realdir": "src_ggm2_ggm-vm_audio.js",
   "realdirNoReplacer": "src\\ggm2\\ggm-vm\\audio.js",
   "uncompileddata": "window.audioEngine = {\r\n\taddToPreload: async function (url) {\r\n\t\tvar request = await fetch(url);\r\n\t\tvar data = await request.arrayBuffer();\r\n\t\twindow.audioEngine.audPreload[url] = window.audioEngine.copyArrayBuffer(window.audioEngine.audPreload[url]);\r\n\t},\r\n\taudPreload: {},\r\n\tcopyArrayBuffer: function (src)  {\r\n\t\tvar dst = new ArrayBuffer(src.byteLength);\r\n\t\tnew Uint8Array(dst).set(new Uint8Array(src));\r\n\t\treturn dst;\r\n\t},\r\n\tsfx:{\r\n\t\taudio:null,\r\n\t\taudioelements:[],\r\n\t\tplay:async function (a) {\r\n\t\t\t/**\r\n\t\t\tBug Fix!\r\n\t\t\t\r\n\t\t\tfixed the audio bug when playing mutiple sounds, including long ones,\r\n\t\t\tmaking it imposible to stop in desktop app.\r\n\t\t\t\r\n\t\t\t*/\r\n\t\t\twindow.audioEngine.audioRunning = true;\r\n\t\t\tif (!(window.audioEngine.audPreload[a])) {\r\n\t\t\t\tvar request = await fetch(a);\r\n\t\t\t\tvar data = await request.arrayBuffer();\r\n\t\t\t\twindow.audioEngine.audPreload[a] = window.audioEngine.copyArrayBuffer(data);\r\n\t\t\t} else {\r\n\t\t\t\tvar data = window.audioEngine.copyArrayBuffer(window.audioEngine.audPreload[a]);\r\n\t\t\t}\r\n\t\t\tvar audioBuffer = await window.audioEngine.decodeAudioDataAsync(data);\r\n\t\t\tvar source = window.audioEngine.context.createBufferSource();\r\n\t\t\tif (window.audioEngine.audioRunning) {\r\n\t\t\t\tsource.buffer = audioBuffer;\r\n\t\t\t\tthis.source = source;\r\n\t\t\t\t\r\n\t\t\t\tsource.connect(window.audioEngine.context.destination);\r\n\t\t\t\tsource.loop = false;\r\n\t\t\t\tsource.start();\r\n\t\t\t\twindow.audioEngine.sources.push(source);\r\n\t\t\t\tsource.onended = function () {\r\n\t\t\t\t\tvar dat = [];\r\n\t\t\t\t\tfor (var obj of window.audioEngine.sources) {\r\n\t\t\t\t\t\tif (!(obj == source)) {\r\n\t\t\t\t\t\t\tdat.push(obj);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\twindow.audioEngine.sources = dat;\r\n\t\t\t\t};\r\n\t\t\t}\r\n/* \t\t\t//bug pach starts here\r\n\t\t\tthis.audio.onended = function () {\r\n\t\t\t\tdelete audioEngine.sfx.audioelements.indexOf(this.audio);\r\n\t\t\t\tvar allSfx = [];\r\n\t\t\t\tfor (var i in audioEngine.sfx.audioelements) {\r\n\t\t\t\t\tif (audioEngine.sfx.audioelements) {\r\n\t\t\t\t\t\tallSfx.push(audioEngine.sfx.audioelements[i]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\taudioEngine.sfx.audioelements = allSfx;\r\n\t\t\t}; */\r\n\t\t}\r\n\t},\r\n\tdecodeAudioDataAsync: (data) => {\r\n\t\treturn new Promise((resolve,reject) => {\r\n\t\t\twindow.audioEngine.context.decodeAudioData(data,resolve,reject);\r\n\t\t})\r\n\t},\r\n\tsources: [\r\n\t\r\n\t],\r\n\taudioRunning:false,\r\n\tbgm:{\r\n\t\taudio:{src:\"\"},\r\n\t\tisPlaying:false,\r\n\t\trunning:false,\r\n\t\tstopRunningSource: () => {\r\n\t\t\tif (this.source) {\r\n\t\t\t\ttry{\r\n\t\t\t\t\tthis.source.stop();\r\n\t\t\t\t}catch(e){}\r\n\t\t\t}\r\n\t\t},\r\n\t\tplay:async function () {\r\n\t\t\ttry{\r\n\t\t\t\tthis.running = true;\r\n\t\t\t\tthis.isPlaying = false;\r\n\t\t\t\tthis.stopRunningSource();\r\n\t\t\t\tvar source = window.audioEngine.context.createBufferSource();\r\n\t\t\t\twindow.audioEngine.sources.push(source);\r\n\t\t\t\twindow.audioEngine.audioRunning = true;\r\n\t\t\t\tif (!(window.audioEngine.audPreload[this.audio.src])) {\r\n\t\t\t\t\tthis.stopRunningSource();\r\n\t\t\t\t\tvar request = await fetch(this.audio.src);\r\n\t\t\t\t\tthis.stopRunningSource();\r\n\t\t\t\t\tthis.isPlaying = false;\r\n\t\t\t\t\tthis.stopRunningSource();\r\n\t\t\t\t\tvar data = await request.arrayBuffer();\r\n\t\t\t\t\tthis.stopRunningSource();\r\n\t\t\t\t\tthis.isPlaying = false;\r\n\t\t\t\t\twindow.audioEngine.audPreload[this.audio.src] = window.audioEngine.copyArrayBuffer(data);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.isPlaying = false;\r\n\t\t\t\t\tthis.stopRunningSource();\r\n\t\t\t\t\tvar data = window.audioEngine.copyArrayBuffer(window.audioEngine.audPreload[this.audio.src]);\r\n\t\t\t\t\tthis.isPlaying = false;\r\n\t\t\t\t\tthis.stopRunningSource();\r\n\t\t\t\t}\r\n\t\t\t\tthis.isPlaying = false;\r\n\t\t\t\tthis.stopRunningSource();\r\n\t\t\t\tvar audioBuffer = await window.audioEngine.decodeAudioDataAsync(data);\r\n\t\t\t\tthis.stopRunningSource();\r\n\t\t\t\tthis.isPlaying = false;\r\n\t\t\t\tsource.buffer = audioBuffer;\r\n\t\t\t\tthis.isPlaying = false;\r\n\t\t\t\tsource.connect(window.audioEngine.context.destination);\r\n\t\t\t\tsource.loop = true;\r\n\t\t\t\tthis.isPlaying = false;\r\n\t\t\t\tif (this.source) {\r\n\t\t\t\t\ttry{\r\n\t\t\t\t\t\tthis.source.stop();\r\n\t\t\t\t\t}catch(e){}\r\n\t\t\t\t}\r\n\t\t\t\tthis.source = source;\r\n\t\t\t\tif (window.audioEngine.audioRunning) {\r\n\t\t\t\t\tif (!(this.isPlaying)) {\r\n\t\t\t\t\t\tthis.isPlaying = true;\r\n\t\t\t\t\t\tsource.start();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}catch(e){\r\n\t\t\t\tconsole.warn(\"[AudioEngine]:error ignored\" + e);\r\n\t\t\t};\r\n\t\t},\r\n\t\tsetSrc:function (a) {\r\n\t\t\tthis.audio.src = a;\r\n\t\t}\r\n\t},\r\n\taudPreload:{\r\n\t\t\r\n\t},\r\n\tstop:function () {\r\n\t\ttry{\r\n\t\tif (this.sfx.audio) {\r\n\t\t\tthis.sfx.audio.pause();\r\n\t\t\tthis.sfx.audio = null;\r\n\t\t}\r\n\t\tthis.bgm.running = false;\r\n\t\tthis.bgm.isPlaying = false;\r\n\t\tthis.audioRunning = false;\r\n\t\tfor (var source of this.sources) {\r\n\t\t\ttry{\r\n\t\t\t\tsource.stop()\r\n\t\t\t}catch(e){}\r\n\t\t}\r\n\t\tthis.sources = [];\r\n\t\t}catch(e){\r\n\t\t\tconsole.warn(\"[AudioEngine]:error ignored\" + e);\r\n\t\t};\r\n\t\tvm.betterAudio.stopAllAudios();\r\n\t},\r\n\ttickAudio:function () {\r\n\t\t//console.log(this.bgm.isPlaying);\r\n\t\tif (window.audioEngine.bgm.isPlaying) {\r\n\t\t\t//if (!(window.audioEngine.bgm.running)) {\r\n\t\t\t//\twindow.audioEngine.bgm.play();\r\n\t\t\t//}\r\n\t\t} else {\r\n\t\t\ttry{\r\n\t\t\t\twindow.audioEngine.bgm.running = false;\r\n\t\t\t\twindow.audioEngine.bgm.source.stop();\r\n\t\t\t}catch(e){}\r\n\t\t}\r\n\t}\r\n}\r\nwindow.audioEngine.bgm.audio.loop = true;\r\nsetInterval(window.audioEngine.tickAudio,1);\r\nwindow.audioEngine.context = new AudioContext();\r\nsetInterval(() => {\r\n\tif (!(window.audioEngine.context.state == \"running\")) {\r\n\t\twindow.audioEngine.context = new AudioContext\r\n\t}\r\n},10);\r\n/*\r\nthe idea was to use context, but scrapped, because of more load lag and how mutch time it takes\r\nwindow.audioEngine = {\r\n\tcontext:new AudioContext(),\r\n\tsource: null,\r\n\tsources:[],\r\n\tapiGetAudio: async (audioBufferData,callback) => {\r\n\t  const context = window.audioEngine.context;\r\n\t\tfunction copy(src)  {\r\n\t\t\tvar dst = new ArrayBuffer(src.byteLength);\r\n\t\t\tnew Uint8Array(dst).set(new Uint8Array(src));\r\n\t\t\treturn dst;\r\n\t\t}\r\n\t  context.decodeAudioData(copy(audioBufferData),function (audioBuffer) {\r\n\t\twindow.audioEngine.source = context.createBufferSource();\r\n\t\tvar source = window.audioEngine.source\r\n\t\tsource.buffer = audioBuffer;\r\n\t\tsource.connect(context.destination);\r\n\t\tsource.start();\r\n\t\twindow.audioEngine.sources.push(source);\r\n\t\tsource.running = true;\r\n\t\tsource.onended = function () {\r\n\t\t\tif (callback) {\r\n\t\t\t\tdelete window.audioEngine.sources.indexOf(source);\r\n\t\t\t\tvar sources = [];\r\n\t\t\t\tfor (var i in window.audioEngine.sources) {\r\n\t\t\t\t\tif (window.audioEngine.sources[i]){\r\n\t\t\t\t\t\tsources.push(window.audioEngine.sources[i]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\twindow.audioEngine.sources = sources;\r\n\t\t\t\tcallback(source);\r\n\t\t\t}\r\n\t\t};\r\n\t  });\r\n\t},\r\n\tsfx:{\r\n\t\taudio:null,\r\n\t\tplay:function (a) {\r\n\t\t\tfetch(a).then((a) => {a.arrayBuffer().then((data) => {\r\n\t\t\t\twindow.audioEngine.apiGetAudio(data);\r\n\t\t\t})});\r\n\t\t}\r\n\t},\r\n\tbgm:{\r\n\t\taudio:\"\",\r\n\t\tisPlaying:false,\r\n\t\tplay:function () {\r\n\t\t\tconsole.log(\"loading audio data\")\r\n\t\t\tfetch(window.audioEngine.bgm.audio).then((data1) => {data1.arrayBuffer().then((data) => {\r\n\t\t\t\tconsole.log(\"playing audio.\");\r\n\t\t\t\twindow.audioEngine.apiGetAudio(data,function (source) {\r\n\t\t\t\t\tif (source.running) {\r\n\t\t\t\t\t\twindow.audioEngine.bgm.play();\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t})});\r\n\t\t},\r\n\t\tpause:function () {\r\n\t\t\tfor (var i in window.audioEngine.sources) {\r\n\t\t\t\ttry{\r\n\t\t\t\t\twindow.audioEngine.sources[i].stop();\r\n\t\t\t\t\twindow.audioEngine.sources[i].running = false;\r\n\t\t\t\t}catch(e){console.warn(`[AudioEngine]:Failed to stop audio context source: ${e}`);}\r\n\t\t\t}\r\n\t\t},\r\n\t\tsetSrc:function (a) {\r\n\t\t\twindow.audioEngine.bgm.audio = a;\r\n\t\t}\r\n\t},\r\n\tstop:function () {\r\n\t\ttry{\r\n\t\tthis.bgm.isPlaying = false;\r\n\t\t}catch(e){\r\n\t\t\tconsole.warn(\"[AudioEngine]:error ignored\" + e);\r\n\t\t};\r\n\t},\r\n\ttickAudio:function () {\r\n\t\tif (window.audioEngine.bgm.isPlaying == true) {\r\n\t\t\twindow.audioEngine.bgm.isPlaying = false;\r\n\t\t\twindow.audioEngine.bgm.play();\r\n\t\t} else {\r\n\t\t\tif (window.audioEngine.bgm.isPlaying == false) {\r\n\t\t\t\twindow.audioEngine.bgm.isPlaying = null;\r\n\t\t\t\twindow.audioEngine.bgm.pause();\r\n\t\t\t} else {\r\n\t\t\t\twindow.audioEngine.bgm.isPlaying = null;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (!(audioEngine.context.state == \"running\")) {\r\n\t\t\taudioEngine.context = new AudioContext();\r\n\t\t}\r\n\t},\r\n\tactive:false\r\n}\r\nwindow.audioEngine.bgm.audio.loop = true;\r\nsetInterval(window.audioEngine.tickAudio,1);*/"
  },
  {
   "data": "(function () {\n//ignore these variables, for the module stuff.\n    var module = {exports:null,filename:JSON.stringify(name)};\n    var require = function (a) {return gp_require(a,\"src\\\\ggm2\\\\ggm-vm\\\\better-audio-ctx.js\");};\n    var var__gvbvdxx_pack_filedata = null; //prevent overwrite\n    var cur_file = \"src\\\\ggm2\\\\ggm-vm\\\\better-audio-ctx.js\";\n    var audios = [];\r\n    function stopAllAudios() {\r\n        for (var a of audios) {\r\n            a.pause();\r\n            a.load = function () {};\r\n            a.data = null;\r\n            a.play = function () {};\r\n            a.pause = function () {};\r\n        }\r\n        audios = [];\r\n    }\r\n    var audioCTX = new AudioContext();\r\n    function decodeAsync(d) {\r\n        return new Promise((a) => {\r\n            try {\r\n                audioCTX.decodeAudioData(d, a);\r\n            } catch (e) {\r\n                a(null);\r\n            }\r\n        });\r\n    }\r\n    setInterval(() => {\r\n        if (!(audioCTX.state == \"running\")) {\r\n            audioCTX = new AudioContext();\r\n        }\r\n    }, 1);\r\n    var preload = {};\r\n    class AudioApiReplacement {\r\n        constructor(url) {\r\n    \r\n            audios.push(this);\r\n            this.dataurl = url;\r\n            this.data = null;\r\n            this.source = null;\r\n            this.playbackRate = 1;\r\n            this.looped = false;\r\n            this.setVolume(1);\r\n        }\r\n        async load() {\r\n            var a = await fetch(this.dataurl);\r\n            var b = await a.arrayBuffer();\r\n            var c = await decodeAsync(b);\r\n            this.data = c;\r\n        }\r\n        play() {\r\n            if (this.data) {\r\n                if (!this.source) {\r\n                    function loadSample(url) {\r\n                        return fetch(url).then((response) => response.arrayBuffer());\r\n                    }\r\n                    const source = audioCTX.createBufferSource();\r\n                    function copy(src) {\r\n                        var dst = new ArrayBuffer(src.byteLength);\r\n                        new Uint8Array(dst).set(new Uint8Array(src));\r\n                        return dst;\r\n                    }\r\n                    this.gainNode = audioCTX.createGain();\r\n                    function decodeAudioData(data, out) {\r\n                        try {\r\n                            out(window.DADF.getFileAudioBuffer(data, audioCTX));\r\n                        } catch (e) {\r\n                            window.alert(e);\r\n                        }\r\n                    }\r\n                    var t = this;\r\n                    function play(buffer) {\r\n                        source.buffer = buffer;\r\n                        source.playbackRate.value = t.playbackRate;\r\n                        source.connect(t.gainNode);\r\n                        t.gainNode.connect(audioCTX.destination);\r\n                        t.gainNode.gain.value = t.startVol;\r\n                        source.looped = t.looped;\r\n                        source.start(0);\r\n                        t.source = source;\r\n    \r\n                        var s = t;\r\n                        source.onended = function () {\r\n                            s.onended();\r\n                            s.source = null;\r\n                        };\r\n                    }\r\n                    function cloneAudioBuffer(fromAudioBuffer) {\r\n                        const audioBuffer = new AudioBuffer({\r\n                            length: fromAudioBuffer.length,\r\n                            numberOfChannels: fromAudioBuffer.numberOfChannels,\r\n                            sampleRate: fromAudioBuffer.sampleRate,\r\n                        });\r\n                        for (\r\n                            let channelI = 0;\r\n                            channelI < audioBuffer.numberOfChannels;\r\n                            ++channelI) {\r\n                            const samples = fromAudioBuffer.getChannelData(channelI);\r\n                            audioBuffer.copyToChannel(samples, channelI);\r\n                        }\r\n                        return audioBuffer;\r\n                    }\r\n                    try {\r\n                        play(cloneAudioBuffer(this.data));\r\n                    } catch (e) {\r\n                        window.alert(e);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        onended() {\r\n            /*Gets overwritten by the script.*/\r\n        }\r\n        pause() {\r\n            if (this.source) {\r\n                this.source.stop();\r\n                this.source = null;\r\n                this.gainNode = null;\r\n            }\r\n        }\r\n        remove() {\r\n            delete this;\r\n        }\r\n        setPlaybackRate(value) {\r\n            if (this.source) {\r\n                this.source.playbackRate.value = value;\r\n                this.playbackRate = value;\r\n            } else {\r\n                this.playbackRate = value;\r\n            }\r\n        }\r\n        getPlaybackRate(value) {\r\n            return this.playbackRate;\r\n        }\r\n        setVolume(value) {\r\n            if (this.source) {\r\n                //console.log(value);\r\n                this.gainNode.gain.value = value;\r\n            } else {\r\n                this.startVol = value;\r\n            }\r\n        }\r\n        getVolume() {\r\n            return this.gainNode.gain.value;\r\n        }\r\n    }\r\n    window.vm.betterAudio = {\r\n        c: AudioApiReplacement,\r\n        preload: preload,\r\n        decodeAsync: decodeAsync,\r\n        audios: audios,\r\n        stopAllAudios: stopAllAudios\r\n    };\r\n    \n    return module;\n})();",
   "name": "src\\ggm2\\ggm-vm\\better-audio-ctx.js",
   "dirname": "src_ggm2_ggm-vm_better-audio-ctx.js",
   "realdir": "src_ggm2_ggm-vm_better-audio-ctx.js",
   "realdirNoReplacer": "src\\ggm2\\ggm-vm\\better-audio-ctx.js",
   "uncompileddata": "var audios = [];\r\nfunction stopAllAudios() {\r\n    for (var a of audios) {\r\n        a.pause();\r\n        a.load = function () {};\r\n        a.data = null;\r\n        a.play = function () {};\r\n        a.pause = function () {};\r\n    }\r\n    audios = [];\r\n}\r\nvar audioCTX = new AudioContext();\r\nfunction decodeAsync(d) {\r\n    return new Promise((a) => {\r\n        try {\r\n            audioCTX.decodeAudioData(d, a);\r\n        } catch (e) {\r\n            a(null);\r\n        }\r\n    });\r\n}\r\nsetInterval(() => {\r\n    if (!(audioCTX.state == \"running\")) {\r\n        audioCTX = new AudioContext();\r\n    }\r\n}, 1);\r\nvar preload = {};\r\nclass AudioApiReplacement {\r\n    constructor(url) {\r\n\r\n        audios.push(this);\r\n        this.dataurl = url;\r\n        this.data = null;\r\n        this.source = null;\r\n        this.playbackRate = 1;\r\n        this.looped = false;\r\n        this.setVolume(1);\r\n    }\r\n    async load() {\r\n        var a = await fetch(this.dataurl);\r\n        var b = await a.arrayBuffer();\r\n        var c = await decodeAsync(b);\r\n        this.data = c;\r\n    }\r\n    play() {\r\n        if (this.data) {\r\n            if (!this.source) {\r\n                function loadSample(url) {\r\n                    return fetch(url).then((response) => response.arrayBuffer());\r\n                }\r\n                const source = audioCTX.createBufferSource();\r\n                function copy(src) {\r\n                    var dst = new ArrayBuffer(src.byteLength);\r\n                    new Uint8Array(dst).set(new Uint8Array(src));\r\n                    return dst;\r\n                }\r\n                this.gainNode = audioCTX.createGain();\r\n                function decodeAudioData(data, out) {\r\n                    try {\r\n                        out(window.DADF.getFileAudioBuffer(data, audioCTX));\r\n                    } catch (e) {\r\n                        window.alert(e);\r\n                    }\r\n                }\r\n                var t = this;\r\n                function play(buffer) {\r\n                    source.buffer = buffer;\r\n                    source.playbackRate.value = t.playbackRate;\r\n                    source.connect(t.gainNode);\r\n                    t.gainNode.connect(audioCTX.destination);\r\n                    t.gainNode.gain.value = t.startVol;\r\n                    source.looped = t.looped;\r\n                    source.start(0);\r\n                    t.source = source;\r\n\r\n                    var s = t;\r\n                    source.onended = function () {\r\n                        s.onended();\r\n                        s.source = null;\r\n                    };\r\n                }\r\n                function cloneAudioBuffer(fromAudioBuffer) {\r\n                    const audioBuffer = new AudioBuffer({\r\n                        length: fromAudioBuffer.length,\r\n                        numberOfChannels: fromAudioBuffer.numberOfChannels,\r\n                        sampleRate: fromAudioBuffer.sampleRate,\r\n                    });\r\n                    for (\r\n                        let channelI = 0;\r\n                        channelI < audioBuffer.numberOfChannels;\r\n                        ++channelI) {\r\n                        const samples = fromAudioBuffer.getChannelData(channelI);\r\n                        audioBuffer.copyToChannel(samples, channelI);\r\n                    }\r\n                    return audioBuffer;\r\n                }\r\n                try {\r\n                    play(cloneAudioBuffer(this.data));\r\n                } catch (e) {\r\n                    window.alert(e);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    onended() {\r\n        /*Gets overwritten by the script.*/\r\n    }\r\n    pause() {\r\n        if (this.source) {\r\n            this.source.stop();\r\n            this.source = null;\r\n            this.gainNode = null;\r\n        }\r\n    }\r\n    remove() {\r\n        delete this;\r\n    }\r\n    setPlaybackRate(value) {\r\n        if (this.source) {\r\n            this.source.playbackRate.value = value;\r\n            this.playbackRate = value;\r\n        } else {\r\n            this.playbackRate = value;\r\n        }\r\n    }\r\n    getPlaybackRate(value) {\r\n        return this.playbackRate;\r\n    }\r\n    setVolume(value) {\r\n        if (this.source) {\r\n            //console.log(value);\r\n            this.gainNode.gain.value = value;\r\n        } else {\r\n            this.startVol = value;\r\n        }\r\n    }\r\n    getVolume() {\r\n        return this.gainNode.gain.value;\r\n    }\r\n}\r\nwindow.vm.betterAudio = {\r\n    c: AudioApiReplacement,\r\n    preload: preload,\r\n    decodeAsync: decodeAsync,\r\n    audios: audios,\r\n    stopAllAudios: stopAllAudios\r\n};\r\n"
  },
  {
   "data": "(function () {\n//ignore these variables, for the module stuff.\n    var module = {exports:null,filename:JSON.stringify(name)};\n    var require = function (a) {return gp_require(a,\"src\\\\ggm2\\\\ggm-vm\\\\classes\\\\sprite.js\");};\n    var var__gvbvdxx_pack_filedata = null; //prevent overwrite\n    var cur_file = \"src\\\\ggm2\\\\ggm-vm\\\\classes\\\\sprite.js\";\n    var console = require(\"log\");\r\n    class GGM2Sprite {\r\n        constructor (id) {\r\n            //the sprites cordinates, just like scratch, cordinates are from the center.\r\n            this.x = 0;\r\n            this.y = 0;\r\n            //the rotation of the sprite, just like scratch, 90 is up right.\r\n            this.direction = 90;\r\n            //size of sprite, also helps center the sprite.\r\n            this.width = 32;\r\n            this.height = 32;\r\n            //the costume/skin of the sprite.\r\n            this.image = null;\r\n            //flip the sprite and stuff.\r\n            this.flip = \"none\";\r\n            //used for deletion.\r\n            this.id = id;\r\n            //the ghost effect of the sprite, the closer it is to 100 the more see-through it gets.\r\n            this.ghost = 0;\r\n            //every time it gets clicked, all the functions in this array get called.\r\n            this.clicked = [];\r\n            //local variables.\r\n            this.localvars = {};\r\n            //is a sprite.\r\n            this.isSprite = true;\r\n        }\r\n    }\r\n    module.exports = GGM2Sprite;\n    return module;\n})();",
   "name": "src\\ggm2\\ggm-vm\\classes\\sprite.js",
   "dirname": "src_ggm2_ggm-vm_classes_sprite.js",
   "realdir": "src_ggm2_ggm-vm_classes_sprite.js",
   "realdirNoReplacer": "src\\ggm2\\ggm-vm\\classes\\sprite.js",
   "uncompileddata": "var console = require(\"log\");\r\nclass GGM2Sprite {\r\n\tconstructor (id) {\r\n\t\t//the sprites cordinates, just like scratch, cordinates are from the center.\r\n\t\tthis.x = 0;\r\n\t\tthis.y = 0;\r\n\t\t//the rotation of the sprite, just like scratch, 90 is up right.\r\n\t\tthis.direction = 90;\r\n\t\t//size of sprite, also helps center the sprite.\r\n\t\tthis.width = 32;\r\n\t\tthis.height = 32;\r\n\t\t//the costume/skin of the sprite.\r\n\t\tthis.image = null;\r\n\t\t//flip the sprite and stuff.\r\n\t\tthis.flip = \"none\";\r\n\t\t//used for deletion.\r\n\t\tthis.id = id;\r\n\t\t//the ghost effect of the sprite, the closer it is to 100 the more see-through it gets.\r\n\t\tthis.ghost = 0;\r\n\t\t//every time it gets clicked, all the functions in this array get called.\r\n\t\tthis.clicked = [];\r\n\t\t//local variables.\r\n\t\tthis.localvars = {};\r\n\t\t//is a sprite.\r\n\t\tthis.isSprite = true;\r\n\t}\r\n}\r\nmodule.exports = GGM2Sprite;"
  },
  {
   "data": "(function () {\n//ignore these variables, for the module stuff.\n    var module = {exports:null,filename:JSON.stringify(name)};\n    var require = function (a) {return gp_require(a,\"src\\\\ggm2\\\\ggm-vm\\\\index.js\");};\n    var var__gvbvdxx_pack_filedata = null; //prevent overwrite\n    var cur_file = \"src\\\\ggm2\\\\ggm-vm\\\\index.js\";\n    var console = require(\"log\");\r\n    var ggm2path = require(\"src/paths.js\");\r\n    var Sprite = require(\"src/\" + ggm2path + \"/ggm-vm/classes/sprite.js\");\r\n    window.vm = {\r\n        daysSince2000: function () {\r\n            const msPerDay = 24 * 60 * 60 * 1000;\r\n            const start = new Date(2000, 0, 1); // Months are 0-indexed.\r\n            const today = new Date();\r\n            const dstAdjust = today.getTimezoneOffset() - start.getTimezoneOffset();\r\n            let mSecsSinceStart = today.valueOf() - start.valueOf();\r\n            mSecsSinceStart += ((today.getTimezoneOffset() - dstAdjust) * 60 * 1000);\r\n            return mSecsSinceStart / msPerDay;\r\n        },\r\n        messageData: [],\r\n        idcounter: 0,\r\n        startTime: 0,\r\n        resetTimer: () => {\r\n            vm.startTime = vm.daysSince2000() * 86400;\r\n            vm.project.timer = 0;\r\n        },\r\n        control: {\r\n            start: async function (a) {\r\n                if (vm.audioEngine) {\r\n                    if (vm.renderer) {\r\n                        for (var m of vm.messageData) {\r\n                            vm.messages[m] = [];\r\n                        }\r\n                        vm.control.stop();\r\n                        vm.resetTimer();\r\n                        vm.control.running = true;\r\n                        vm.idcounter = 0;\r\n                        vm.project.monitors = [];\r\n                        window.vm.renderer.camghost = 0;\r\n                        window.vm.renderer.bg.src = \"\";\r\n                        try {\r\n                            eval(\"(async function () {\\ntry{\\n\" + vm.code + \"\\n} catch (e) {\\nvm.console.error(e);\\n}\\n})();\");\r\n                        } catch (e) {\r\n                            vm.console.error(\"Error in script:\" + e);\r\n                        }\r\n                    } else {\r\n                        throw Error(\"Renderer Must Be Attached\");\r\n                    }\r\n                } else {\r\n                    throw Error(\"AudioEngine Must Be Attached\");\r\n                }\r\n            },\r\n            stop: function () {\r\n                for (var i in vm.project.timeouts) {\r\n                    clearTimeout(vm.project.timeouts[i]);\r\n                }\r\n                vm.project.timeouts = [];\r\n                vm.idcounter = 0;\r\n                vm.control.running = false;\r\n                vm.project.sprites = [];\r\n                vm.project.events.tick = [];\r\n                vm.project.sprites = [];\r\n                vm.project.keysPressed = [];\r\n                vm.project.keyListeners = {};\r\n                vm.audioEngine.stop();\r\n                try {\r\n                    window.vm.onstop();\r\n                } catch (e) {\r\n                    console.error(e);\r\n                }\r\n            },\r\n            running: false\r\n        },\r\n        code: \"\",\r\n        renderer: null,\r\n        attachRenderer: function (a) {\r\n            vm.renderer = a;\r\n            vm.renderer.start();\r\n            return a;\r\n        },\r\n        attachAudioEngine: function (a) {\r\n            vm.audioEngine = a;\r\n            return a;\r\n        },\r\n        setCompiadiblityMode: function (a) {\r\n            this.compiadiblityMode = a;\r\n        },\r\n        compiadiblityMode: false,\r\n        messages: {},\r\n        project: {\r\n            keyListeners: {},\r\n            mouseDown: false,\r\n            mouseX: 0,\r\n            mouseY: 0,\r\n            keysPressed: [],\r\n            sprites: [],\r\n            events: {\r\n                tick: []\r\n            },\r\n            monitors: [],\r\n            resources: [],\r\n            timer: 0,\r\n            timeouts: [],\r\n            block: {\r\n                convertURLToText: function (url) {\r\n                    try {\r\n                        return atob(url.split(\",\").pop());\r\n                    } catch (e) {\r\n                        vm.console.error(\"Error in script:\" + e);\r\n                    }\r\n                },\r\n                cloudVarSet: function (name, value) {\r\n                    try {\r\n                        if (vm.cloudAPI) {\r\n                            vm.cloudAPI.updateVariable(name, value);\r\n                        }\r\n                    } catch (e) {\r\n                        vm.console.error(\"Error in script:\" + e);\r\n                    }\r\n                },\r\n                cloudVarGet: function (name) {\r\n                    try {\r\n                        if (vm.cloudAPI) {\r\n                            var realValue = vm.cloudAPI.getVariable(name);\r\n                            //so users can understand the blocks easier\r\n                            if (Number(realValue)) {\r\n                                realValue = Number(realValue);\r\n                            }\r\n                            return realValue;\r\n                        }\r\n                    } catch (e) {\r\n                        vm.console.error(\"Error in script:\" + e);\r\n                    }\r\n                },\r\n                tickAsync: function () {\r\n                    return new Promise((a) => {\r\n                        setTimeout(a, 1);\r\n                    })\r\n                },\r\n                saveFileFromText: function (name,type,contents) {\r\n                    var myFile = new Blob([contents], {\r\n                        type: type\r\n                    });\r\n                    \r\n                    var objectURL = window.URL || window.webkitURL;\r\n                    var a = document.createElement(\"a\");\r\n    \r\n                    a.href = objectURL.createObjectURL(myFile);\r\n                    a.download = name;\r\n                    a.click();\r\n                },\r\n                loadFileAsText: function (extensions,callback) {\r\n                    var objectURL = window.URL || window.webkitURL;\r\n                    var input = document.createElement(\"input\");\r\n                    input.type = \"file\";\r\n                    input.accept = extensions;\r\n                    input.click();\r\n                    \r\n                    input.onchange = function () {\r\n                        if (input.files.length > 0) {\r\n                            var file = input.files[0];\r\n                            var reader = new FileReader();\r\n                            reader.onload = function () {\r\n                                callback(reader.result);\r\n                                input.remove();\r\n                            };\r\n                            reader.readAsText(file);\r\n                        }\r\n                    };\r\n                },\r\n                waitAsync: function (s) {\r\n                    return new Promise((a) => {\r\n                        vm.project.timeouts.push(setTimeout(a, s * 1000));\r\n                    })\r\n                },\r\n                moveSteps: function (sprite, steps) {\r\n                    try {\r\n                        var realsteps = steps;\r\n                        var realdir = 90 - sprite.direction;\r\n                        var xBy = Math.cos(realdir * (Math.PI / 180)) * realsteps;\r\n                        var yBy = Math.sin(realdir * (Math.PI / 180)) * realsteps;\r\n                        var realxby = xBy + xBy;\r\n                        sprite.x = sprite.x + realxby;\r\n                        sprite.y = sprite.y + (yBy + yBy);\r\n                    } catch (e) {\r\n                        vm.console.error(\"Error in script:\" + e);\r\n                    }\r\n                },\r\n                deleteList: function (array, number) {\r\n                    try {\r\n                        delete array[number];\r\n                        var index = 0;\r\n                        var genaratedArray = [];\r\n                        while (array.length > index) {\r\n                            if (!(array[index] == undefined)) {\r\n                                genaratedArray.push(array[index]);\r\n                            }\r\n                            index += 1;\r\n                        }\r\n                        return genaratedArray;\r\n                    } catch (e) {\r\n                        vm.console.error(\"Error in script:\" + e);\r\n                    }\r\n                },\r\n                makeSprite: function () {\r\n                    try {\r\n                        vm.idcounter += 1;\r\n                        var realID = vm.project.sprites.length-1;\r\n                        var spr = new Sprite(realID);\r\n                        this.showSprite(spr);\r\n                        return spr;\r\n                        try {\r\n                            window.vm.onspritecreate(spr);\r\n                        } catch (e) {\r\n                            console.error(e);\r\n                        }\r\n                    } catch (e) {}\r\n    \r\n                },\r\n                makeMonitor: function () {\r\n                    try {\r\n                        var monitor = {\r\n                            x: 0,\r\n                            y: 0,\r\n                            value: 0,\r\n                            name: \"monitor\",\r\n                            visible: true,\r\n                            clicked: []\r\n                        };\r\n                        window.vm.project.monitors.push(monitor);\r\n                        return monitor;\r\n                    } catch (e) {\r\n                        vm.console.error(\"Error in script:\" + e);\r\n                    }\r\n                },\r\n                showSprite: function (spr) {\r\n                    try {\r\n                        this.hideSprite(spr); //ensure there is only one sprite when showing again.\r\n                        vm.project.sprites.push(spr);\r\n                        var counter = 0;\r\n                        for (var spr2 of vm.project.sprites) {\r\n                            spr2.id = counter;\r\n                            counter += 1;\r\n                        }\r\n                    } catch (e) {\r\n                        vm.console.error(\"Error in script:\" + e);\r\n                    }\r\n                },\r\n                hideSprite: function (spr) {\r\n                    try {\r\n                        var i = vm.project.sprites.indexOf(spr);\r\n                        if (i > -1) {\r\n                            vm.project.sprites.splice(i, 1); // 2nd parameter means remove one item only\r\n                        }\r\n                        \r\n                        var counter = 0;\r\n                        for (var spr2 of vm.project.sprites) {\r\n                            spr2.id = counter;\r\n                            counter += 1;\r\n                        }\r\n                    } catch (e) {}\r\n                },\r\n                cos: function (number) {\r\n                    try {\r\n                        return Math.cos((number) * (Math.PI / 180));\r\n                    } catch (e) {\r\n                        vm.console.error(e);\r\n                    }\r\n                },\r\n                sin: function (number) {\r\n                    try {\r\n                        return Math.sin((number) * (Math.PI / 180));\r\n                    } catch (e) {\r\n                        vm.console.error(e);\r\n                    }\r\n                },\r\n                getMoseData: function () {\r\n                    try {\r\n                        return {\r\n                            x: vm.project.mouseX,\r\n                            y: vm.project.mouseY,\r\n                            down: vm.project.mouseDown\r\n                        };\r\n                    } catch (e) {}\r\n                },\r\n                dataToImg: function (dataURI) {\r\n                    try {\r\n                        var img = document.createElement(\"img\");\r\n                        img.src = dataURI;\r\n                        img.setAttribute(\"style\", \"image-rendering: pixelated;\");\r\n                        return img;\r\n                    } catch (e) {}\r\n                },\r\n                random: function (a, b) {\r\n                    if (a > b) {\r\n                        // Swap a and b to ensure a is smaller.\r\n                        var c = a;\r\n                        a = b;\r\n                        b = c;\r\n                    }\r\n                    return Math.floor(Math.random() * (b - a + 1) + a);\r\n                },\r\n                isTouching: function (sprite1, sprite2, mode) {\r\n                    /*if (sp1.x > sp2.x) {\r\n                    var devideNumX = -2;\r\n                    } else {\r\n                    var devideNumX = 2;\r\n                    }\r\n                    sp1.x -= sp1.width/devideNumX;\r\n                    var res = (\r\n                    sp1.x < sp2.x + (sp2.width/1) &&\r\n                    sp1.x + (sp1.width/1) > sp2.x &&\r\n                    sp1.y < sp2.y + sp2.height &&\r\n                    sp1.height + sp1.y > sp2.y\r\n                    );\r\n                    sp1.x += sp1.width/devideNumX;\r\n                    return res;*/\r\n                    try {\r\n                        return vm.___CHECKCOLLIDE(sprite1, sprite2);\r\n                    } catch (e) {\r\n                        vm.console.error(\"Error in script:\" + e);\r\n                    }\r\n                },\r\n                getKeyPressed: function (keyname) {\r\n                    try {\r\n                        if (vm.project.keysPressed[keyname]) {\r\n                            return true;\r\n                        } else {\r\n                            return false;\r\n                        }\r\n                    } catch (e) {}\r\n                },\r\n                wait: function (secs, callback) {\r\n                    try {\r\n                        /**Update For V1.5.0!\r\n                        Fixed A Bug Where If You Stop The Project And Run It,\r\n                        All The Waits Will Run If They Are Not Over Yet.\r\n                        To Fix This, I Used An clearTimeout() Function For Each One.\r\n                         */\r\n                        vm.project.timeouts.push(setTimeout(() => {\r\n                                if (window.vm.control.running) {\r\n                                    callback();\r\n                                }\r\n                            }, secs * 1000)); /*1000ms = 1 second*/\r\n                    } catch (e) {}\r\n                },\r\n                getTouchMouse: function (spr) {\r\n                    return window.vm.___CHECKCOLLIDE({\r\n                        x: window.vm.project.mouseX,\r\n                        y: window.vm.project.mouseY,\r\n                        width: 1,\r\n                        height: 1\r\n                    }, spr);\r\n                },\r\n                changeColorEffect: function (img, r, g, b) {\r\n                    img.src = window.vm.renderer.getColorEffect(img, r, g, b);\r\n                },\r\n                micVolume: function () {\r\n                    if (window.vm.renderer.camrun) {\r\n                        return window.vm.renderer.micvol;\r\n                    } else {\r\n                        return 0;\r\n                    }\r\n                },\r\n                openCamera: function () {\r\n                    window.vm.renderer.startCameraStream();\r\n                },\r\n                stopCamera: function () {\r\n                    window.vm.renderer.stopCameraStream();\r\n                }\r\n            }\r\n        },\r\n        variables: {\r\n            canDrag: false\r\n        },\r\n        vmTick: function () {\r\n            if (vm.control.running) {\r\n                vm.project.timer = (vm.daysSince2000() * 86400) - vm.startTime;\r\n                for (var i in vm.project.events.tick) {\r\n                    try {\r\n                        vm.project.events.tick[i]()\r\n                    } catch (e) {\r\n                        vm.console.error(e);\r\n                    }\r\n                }\r\n                try {\r\n                    vm.renderer.tick(vm.project.sprites, vm.project.monitors);\r\n                } catch (e) {}\r\n                this.ticks += 0;\r\n                try {\r\n                    window.vm.ontick();\r\n                } catch (e) {\r\n                    console.error(e);\r\n                }\r\n            } else {\r\n                this.ticks = 0;\r\n            }\r\n            window.requestAnimationFrame(vm.vmTick);\r\n        },\r\n        start: function () {\r\n            vm.control.start();\r\n        },\r\n        stop: function () {\r\n            vm.control.stop();\r\n        },\r\n        setMousePos: function (data) {\r\n            this.project.mouseX = data.x;\r\n            this.project.mouseY = data.y;\r\n        },\r\n        setCloudAPI: function (api) {\r\n            this.cloudAPI = api;\r\n        },\r\n        setMouseDown: function (data) {\r\n            if (data == true) {\r\n                for (var i in vm.project.sprites) {\r\n                    try {\r\n                        if (this.___CHECKCOLLIDE({\r\n                                x: this.project.mouseX,\r\n                                y: this.project.mouseY,\r\n                                width: 1,\r\n                                height: 1\r\n                            }, vm.project.sprites[i])) {\r\n                            var currentSprite = vm.project.sprites[i];\r\n                            for (var i2 in currentSprite.clicked) {\r\n                                try {\r\n                                    currentSprite.clicked[i2]()\r\n                                } catch (e) {\r\n                                    vm.console.error(e);\r\n                                }\r\n                            }\r\n                            //console.log(\"clicked sprite.\");\r\n                        }\r\n                    } catch (e) {\r\n                        console.error(e);\r\n                    }\r\n                }\r\n            }\r\n            this.project.mouseDown = data;\r\n        },\r\n        console: {\r\n            log: function (text) {\r\n                console.log(text);\r\n            },\r\n            error: function (text) {\r\n                console.error(text);\r\n                vm.stop();\r\n            },\r\n            clear: function (text) {\r\n                console.clear();\r\n            }\r\n        },\r\n        simulateKey: function (data) {\r\n            if (data.down) {\r\n                this.project.keysPressed[data.key] = true;\r\n                if (this.project.keyListeners[data.key]) {\r\n                    this.project.keyListeners[data.key].forEach((func) => {\r\n                        try {\r\n                            func();\r\n                        } catch (e) {\r\n                            vm.console.error(e);\r\n                        }\r\n                    })\r\n                }\r\n            } else {\r\n                this.project.keysPressed[data.key] = false;\r\n            }\r\n        },\r\n        collideWidth: 0,\r\n        collideHeight: 0,\r\n        ___CHECKCOLLIDE: function (spr1, spr2) {\r\n            return false;\r\n        },\r\n        collideDiv: document.createElement(\"div\"),\r\n        addEventListener: function (name, eventName) {\r\n            this[\"on\" + name] = eventName;\r\n        },\r\n        ontick: function () {},\r\n        onspritecreate: function (sprite) {},\r\n        onstop: function () {},\r\n        __decodeDataBase64URI: function (dataURI) {\r\n            return atob(dataURI.split(\";\").pop().split(\",\").pop());\r\n        }\r\n    }\r\n    vm.___CHECKCOLLIDE = function isCollide(a2, b2) {\r\n        function getRealCanvasPos(x, y, width, height, canvas) {\r\n            var mainX = x - (width / 2);\r\n            var mainY = y - (height / 2);\r\n            return {\r\n                x: mainX - (canvas.width / 2),\r\n                y: mainY - (canvas.height / 2)\r\n            };\r\n        }\r\n        var a = {\r\n            width: a2.width / 2,\r\n            height: a2.height,\r\n            x: getRealCanvasPos(a2.x, a2.y, a2.width / 2, a2.height, vm.renderer.canvas).x,\r\n            y: getRealCanvasPos(a2.x, a2.y, a2.width / 2, a2.height, vm.renderer.canvas).y\r\n        };\r\n        var b = {\r\n            width: b2.width / 2,\r\n            height: b2.height,\r\n            x: getRealCanvasPos(b2.x, b2.y, b2.width / 2, b2.height, vm.renderer.canvas).x,\r\n            y: getRealCanvasPos(b2.x, b2.y, b2.width / 2, b2.height, vm.renderer.canvas).y\r\n        };\r\n        var result = (\r\n            a.x + a.width >= b.x &&\r\n            a.x <= b.x + b.width &&\r\n            a.y + a.height >= b.y &&\r\n            a.y <= b.y + b.height);\r\n        /*if (a2.image) {\r\n        document.body.appendChild(a2.image);\r\n        a2.image.style.position = 'fixed';\r\n        a2.image.style.top = a2.y+(vm.renderer.canvas.height / 2)+'px';\r\n        a2.image.style.left = a2.x+(vm.renderer.canvas.width / 2)+'px';\r\n        a2.image.width = a2.width;\r\n        a2.image.height = a2.height;\r\n        }\r\n        if (b2.image) {\r\n        document.body.appendChild(b2.image);\r\n        b2.image.style.position = 'fixed';\r\n        b2.image.style.top = b2.y+(vm.renderer.canvas.height / 2)+'px';\r\n        b2.image.style.left = b2.x+(vm.renderer.canvas.width / 2)+'px';\r\n        b2.image.width = b2.width;\r\n        b2.image.height = b2.height;\r\n        }*/\r\n        return result;\r\n    };\r\n    window.requestAnimationFrame(vm.vmTick);\r\n    /*\r\n    TEST SCRIPTS:\r\n    while in devlopment I ran code to check if everything is okay and working.\r\n    basic test:\r\n    var sprite = vm.project.block.makeSprite();\r\n    sprite.image = document.getElementById(\"testImage\");\r\n    \r\n    hide sprite test:\r\n    \r\n    vm.project.block.hideSprite(sprite);\r\n    \r\n    second sprite test:\r\n    \r\n    var sprite2 = vm.project.block.makeSprite();\r\n    sprite2.image = document.getElementById(\"testImage\");\r\n    \r\n    rotating sprite test:\r\n    var sprite3 = vm.project.block.makeSprite();\r\n    sprite3.image = document.getElementById(\"testImage\");\r\n    vm.project.events.tick.push(function () {\r\n    sprite3.direction += 1;\r\n    });\r\n    */\r\n    \n    return module;\n})();",
   "name": "src\\ggm2\\ggm-vm\\index.js",
   "dirname": "src_ggm2_ggm-vm_index.js",
   "realdir": "src_ggm2_ggm-vm_index.js",
   "realdirNoReplacer": "src\\ggm2\\ggm-vm\\index.js",
   "uncompileddata": "var console = require(\"log\");\r\nvar ggm2path = require(\"src/paths.js\");\r\nvar Sprite = require(\"src/\" + ggm2path + \"/ggm-vm/classes/sprite.js\");\r\nwindow.vm = {\r\n    daysSince2000: function () {\r\n        const msPerDay = 24 * 60 * 60 * 1000;\r\n        const start = new Date(2000, 0, 1); // Months are 0-indexed.\r\n        const today = new Date();\r\n        const dstAdjust = today.getTimezoneOffset() - start.getTimezoneOffset();\r\n        let mSecsSinceStart = today.valueOf() - start.valueOf();\r\n        mSecsSinceStart += ((today.getTimezoneOffset() - dstAdjust) * 60 * 1000);\r\n        return mSecsSinceStart / msPerDay;\r\n    },\r\n    messageData: [],\r\n    idcounter: 0,\r\n    startTime: 0,\r\n    resetTimer: () => {\r\n        vm.startTime = vm.daysSince2000() * 86400;\r\n        vm.project.timer = 0;\r\n    },\r\n    control: {\r\n        start: async function (a) {\r\n            if (vm.audioEngine) {\r\n                if (vm.renderer) {\r\n                    for (var m of vm.messageData) {\r\n                        vm.messages[m] = [];\r\n                    }\r\n                    vm.control.stop();\r\n                    vm.resetTimer();\r\n                    vm.control.running = true;\r\n                    vm.idcounter = 0;\r\n                    vm.project.monitors = [];\r\n                    window.vm.renderer.camghost = 0;\r\n                    window.vm.renderer.bg.src = \"\";\r\n                    try {\r\n                        eval(\"(async function () {\\ntry{\\n\" + vm.code + \"\\n} catch (e) {\\nvm.console.error(e);\\n}\\n})();\");\r\n                    } catch (e) {\r\n                        vm.console.error(\"Error in script:\" + e);\r\n                    }\r\n                } else {\r\n                    throw Error(\"Renderer Must Be Attached\");\r\n                }\r\n            } else {\r\n                throw Error(\"AudioEngine Must Be Attached\");\r\n            }\r\n        },\r\n        stop: function () {\r\n            for (var i in vm.project.timeouts) {\r\n                clearTimeout(vm.project.timeouts[i]);\r\n            }\r\n            vm.project.timeouts = [];\r\n            vm.idcounter = 0;\r\n            vm.control.running = false;\r\n            vm.project.sprites = [];\r\n            vm.project.events.tick = [];\r\n            vm.project.sprites = [];\r\n            vm.project.keysPressed = [];\r\n            vm.project.keyListeners = {};\r\n            vm.audioEngine.stop();\r\n            try {\r\n                window.vm.onstop();\r\n            } catch (e) {\r\n                console.error(e);\r\n            }\r\n        },\r\n        running: false\r\n    },\r\n    code: \"\",\r\n    renderer: null,\r\n    attachRenderer: function (a) {\r\n        vm.renderer = a;\r\n        vm.renderer.start();\r\n        return a;\r\n    },\r\n    attachAudioEngine: function (a) {\r\n        vm.audioEngine = a;\r\n        return a;\r\n    },\r\n    setCompiadiblityMode: function (a) {\r\n        this.compiadiblityMode = a;\r\n    },\r\n    compiadiblityMode: false,\r\n    messages: {},\r\n    project: {\r\n        keyListeners: {},\r\n        mouseDown: false,\r\n        mouseX: 0,\r\n        mouseY: 0,\r\n        keysPressed: [],\r\n        sprites: [],\r\n        events: {\r\n            tick: []\r\n        },\r\n        monitors: [],\r\n        resources: [],\r\n        timer: 0,\r\n        timeouts: [],\r\n        block: {\r\n            convertURLToText: function (url) {\r\n                try {\r\n                    return atob(url.split(\",\").pop());\r\n                } catch (e) {\r\n                    vm.console.error(\"Error in script:\" + e);\r\n                }\r\n            },\r\n\t\t\tcloudVarSet: function (name, value) {\r\n                try {\r\n                    if (vm.cloudAPI) {\r\n                        vm.cloudAPI.updateVariable(name, value);\r\n                    }\r\n                } catch (e) {\r\n                    vm.console.error(\"Error in script:\" + e);\r\n                }\r\n            },\r\n            cloudVarGet: function (name) {\r\n                try {\r\n                    if (vm.cloudAPI) {\r\n                        var realValue = vm.cloudAPI.getVariable(name);\r\n                        //so users can understand the blocks easier\r\n                        if (Number(realValue)) {\r\n                            realValue = Number(realValue);\r\n                        }\r\n                        return realValue;\r\n                    }\r\n                } catch (e) {\r\n                    vm.console.error(\"Error in script:\" + e);\r\n                }\r\n            },\r\n            tickAsync: function () {\r\n                return new Promise((a) => {\r\n                    setTimeout(a, 1);\r\n                })\r\n            },\r\n\t\t\tsaveFileFromText: function (name,type,contents) {\r\n\t\t\t\tvar myFile = new Blob([contents], {\r\n\t\t\t\t\ttype: type\r\n\t\t\t\t});\r\n\t\t\t\t\r\n\t\t\t\tvar objectURL = window.URL || window.webkitURL;\r\n\t\t\t\tvar a = document.createElement(\"a\");\r\n\r\n\t\t\t\ta.href = objectURL.createObjectURL(myFile);\r\n\t\t\t\ta.download = name;\r\n\t\t\t\ta.click();\r\n\t\t\t},\r\n\t\t\tloadFileAsText: function (extensions,callback) {\r\n\t\t\t\tvar objectURL = window.URL || window.webkitURL;\r\n\t\t\t\tvar input = document.createElement(\"input\");\r\n\t\t\t\tinput.type = \"file\";\r\n\t\t\t\tinput.accept = extensions;\r\n\t\t\t\tinput.click();\r\n\t\t\t\t\r\n\t\t\t\tinput.onchange = function () {\r\n\t\t\t\t\tif (input.files.length > 0) {\r\n\t\t\t\t\t\tvar file = input.files[0];\r\n\t\t\t\t\t\tvar reader = new FileReader();\r\n\t\t\t\t\t\treader.onload = function () {\r\n\t\t\t\t\t\t\tcallback(reader.result);\r\n\t\t\t\t\t\t\tinput.remove();\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t\treader.readAsText(file);\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\t\t\t},\r\n            waitAsync: function (s) {\r\n                return new Promise((a) => {\r\n                    vm.project.timeouts.push(setTimeout(a, s * 1000));\r\n                })\r\n            },\r\n            moveSteps: function (sprite, steps) {\r\n                try {\r\n                    var realsteps = steps;\r\n                    var realdir = 90 - sprite.direction;\r\n                    var xBy = Math.cos(realdir * (Math.PI / 180)) * realsteps;\r\n                    var yBy = Math.sin(realdir * (Math.PI / 180)) * realsteps;\r\n                    var realxby = xBy + xBy;\r\n                    sprite.x = sprite.x + realxby;\r\n                    sprite.y = sprite.y + (yBy + yBy);\r\n                } catch (e) {\r\n                    vm.console.error(\"Error in script:\" + e);\r\n                }\r\n            },\r\n            deleteList: function (array, number) {\r\n                try {\r\n                    delete array[number];\r\n                    var index = 0;\r\n                    var genaratedArray = [];\r\n                    while (array.length > index) {\r\n                        if (!(array[index] == undefined)) {\r\n                            genaratedArray.push(array[index]);\r\n                        }\r\n                        index += 1;\r\n                    }\r\n                    return genaratedArray;\r\n                } catch (e) {\r\n                    vm.console.error(\"Error in script:\" + e);\r\n                }\r\n            },\r\n            makeSprite: function () {\r\n                try {\r\n                    vm.idcounter += 1;\r\n\t\t\t\t\tvar realID = vm.project.sprites.length-1;\r\n                    var spr = new Sprite(realID);\r\n                    this.showSprite(spr);\r\n                    return spr;\r\n                    try {\r\n                        window.vm.onspritecreate(spr);\r\n                    } catch (e) {\r\n                        console.error(e);\r\n                    }\r\n                } catch (e) {}\r\n\r\n            },\r\n            makeMonitor: function () {\r\n                try {\r\n                    var monitor = {\r\n                        x: 0,\r\n                        y: 0,\r\n                        value: 0,\r\n                        name: \"monitor\",\r\n                        visible: true,\r\n                        clicked: []\r\n                    };\r\n                    window.vm.project.monitors.push(monitor);\r\n                    return monitor;\r\n                } catch (e) {\r\n                    vm.console.error(\"Error in script:\" + e);\r\n                }\r\n            },\r\n            showSprite: function (spr) {\r\n                try {\r\n                    this.hideSprite(spr); //ensure there is only one sprite when showing again.\r\n                    vm.project.sprites.push(spr);\r\n\t\t\t\t\tvar counter = 0;\r\n\t\t\t\t\tfor (var spr2 of vm.project.sprites) {\r\n\t\t\t\t\t\tspr2.id = counter;\r\n\t\t\t\t\t\tcounter += 1;\r\n\t\t\t\t\t}\r\n                } catch (e) {\r\n                    vm.console.error(\"Error in script:\" + e);\r\n                }\r\n            },\r\n            hideSprite: function (spr) {\r\n                try {\r\n                    var i = vm.project.sprites.indexOf(spr);\r\n                    if (i > -1) {\r\n                        vm.project.sprites.splice(i, 1); // 2nd parameter means remove one item only\r\n                    }\r\n\t\t\t\t\t\r\n\t\t\t\t\tvar counter = 0;\r\n\t\t\t\t\tfor (var spr2 of vm.project.sprites) {\r\n\t\t\t\t\t\tspr2.id = counter;\r\n\t\t\t\t\t\tcounter += 1;\r\n\t\t\t\t\t}\r\n                } catch (e) {}\r\n            },\r\n            cos: function (number) {\r\n                try {\r\n                    return Math.cos((number) * (Math.PI / 180));\r\n                } catch (e) {\r\n                    vm.console.error(e);\r\n                }\r\n            },\r\n            sin: function (number) {\r\n                try {\r\n                    return Math.sin((number) * (Math.PI / 180));\r\n                } catch (e) {\r\n                    vm.console.error(e);\r\n                }\r\n            },\r\n            getMoseData: function () {\r\n                try {\r\n                    return {\r\n                        x: vm.project.mouseX,\r\n                        y: vm.project.mouseY,\r\n                        down: vm.project.mouseDown\r\n                    };\r\n                } catch (e) {}\r\n            },\r\n            dataToImg: function (dataURI) {\r\n                try {\r\n                    var img = document.createElement(\"img\");\r\n                    img.src = dataURI;\r\n                    img.setAttribute(\"style\", \"image-rendering: pixelated;\");\r\n                    return img;\r\n                } catch (e) {}\r\n            },\r\n            random: function (a, b) {\r\n                if (a > b) {\r\n                    // Swap a and b to ensure a is smaller.\r\n                    var c = a;\r\n                    a = b;\r\n                    b = c;\r\n                }\r\n                return Math.floor(Math.random() * (b - a + 1) + a);\r\n            },\r\n            isTouching: function (sprite1, sprite2, mode) {\r\n                /*if (sp1.x > sp2.x) {\r\n                var devideNumX = -2;\r\n                } else {\r\n                var devideNumX = 2;\r\n                }\r\n                sp1.x -= sp1.width/devideNumX;\r\n                var res = (\r\n                sp1.x < sp2.x + (sp2.width/1) &&\r\n                sp1.x + (sp1.width/1) > sp2.x &&\r\n                sp1.y < sp2.y + sp2.height &&\r\n                sp1.height + sp1.y > sp2.y\r\n                );\r\n                sp1.x += sp1.width/devideNumX;\r\n                return res;*/\r\n                try {\r\n                    return vm.___CHECKCOLLIDE(sprite1, sprite2);\r\n                } catch (e) {\r\n                    vm.console.error(\"Error in script:\" + e);\r\n                }\r\n            },\r\n            getKeyPressed: function (keyname) {\r\n                try {\r\n                    if (vm.project.keysPressed[keyname]) {\r\n                        return true;\r\n                    } else {\r\n                        return false;\r\n                    }\r\n                } catch (e) {}\r\n            },\r\n            wait: function (secs, callback) {\r\n                try {\r\n                    /**Update For V1.5.0!\r\n                    Fixed A Bug Where If You Stop The Project And Run It,\r\n                    All The Waits Will Run If They Are Not Over Yet.\r\n                    To Fix This, I Used An clearTimeout() Function For Each One.\r\n                     */\r\n                    vm.project.timeouts.push(setTimeout(() => {\r\n                            if (window.vm.control.running) {\r\n                                callback();\r\n                            }\r\n                        }, secs * 1000)); /*1000ms = 1 second*/\r\n                } catch (e) {}\r\n            },\r\n            getTouchMouse: function (spr) {\r\n                return window.vm.___CHECKCOLLIDE({\r\n                    x: window.vm.project.mouseX,\r\n                    y: window.vm.project.mouseY,\r\n                    width: 1,\r\n                    height: 1\r\n                }, spr);\r\n            },\r\n            changeColorEffect: function (img, r, g, b) {\r\n                img.src = window.vm.renderer.getColorEffect(img, r, g, b);\r\n            },\r\n            micVolume: function () {\r\n                if (window.vm.renderer.camrun) {\r\n                    return window.vm.renderer.micvol;\r\n                } else {\r\n                    return 0;\r\n                }\r\n            },\r\n            openCamera: function () {\r\n                window.vm.renderer.startCameraStream();\r\n            },\r\n            stopCamera: function () {\r\n                window.vm.renderer.stopCameraStream();\r\n            }\r\n        }\r\n    },\r\n    variables: {\r\n        canDrag: false\r\n    },\r\n    vmTick: function () {\r\n        if (vm.control.running) {\r\n            vm.project.timer = (vm.daysSince2000() * 86400) - vm.startTime;\r\n            for (var i in vm.project.events.tick) {\r\n                try {\r\n                    vm.project.events.tick[i]()\r\n                } catch (e) {\r\n                    vm.console.error(e);\r\n                }\r\n            }\r\n            try {\r\n                vm.renderer.tick(vm.project.sprites, vm.project.monitors);\r\n            } catch (e) {}\r\n            this.ticks += 0;\r\n            try {\r\n                window.vm.ontick();\r\n            } catch (e) {\r\n                console.error(e);\r\n            }\r\n        } else {\r\n            this.ticks = 0;\r\n        }\r\n        window.requestAnimationFrame(vm.vmTick);\r\n    },\r\n    start: function () {\r\n        vm.control.start();\r\n    },\r\n    stop: function () {\r\n        vm.control.stop();\r\n    },\r\n    setMousePos: function (data) {\r\n        this.project.mouseX = data.x;\r\n        this.project.mouseY = data.y;\r\n    },\r\n    setCloudAPI: function (api) {\r\n        this.cloudAPI = api;\r\n    },\r\n    setMouseDown: function (data) {\r\n        if (data == true) {\r\n            for (var i in vm.project.sprites) {\r\n                try {\r\n                    if (this.___CHECKCOLLIDE({\r\n                            x: this.project.mouseX,\r\n                            y: this.project.mouseY,\r\n                            width: 1,\r\n                            height: 1\r\n                        }, vm.project.sprites[i])) {\r\n                        var currentSprite = vm.project.sprites[i];\r\n                        for (var i2 in currentSprite.clicked) {\r\n                            try {\r\n                                currentSprite.clicked[i2]()\r\n                            } catch (e) {\r\n                                vm.console.error(e);\r\n                            }\r\n                        }\r\n                        //console.log(\"clicked sprite.\");\r\n                    }\r\n                } catch (e) {\r\n                    console.error(e);\r\n                }\r\n            }\r\n        }\r\n        this.project.mouseDown = data;\r\n    },\r\n    console: {\r\n        log: function (text) {\r\n            console.log(text);\r\n        },\r\n        error: function (text) {\r\n            console.error(text);\r\n            vm.stop();\r\n        },\r\n        clear: function (text) {\r\n            console.clear();\r\n        }\r\n    },\r\n    simulateKey: function (data) {\r\n        if (data.down) {\r\n            this.project.keysPressed[data.key] = true;\r\n            if (this.project.keyListeners[data.key]) {\r\n                this.project.keyListeners[data.key].forEach((func) => {\r\n                    try {\r\n                        func();\r\n                    } catch (e) {\r\n                        vm.console.error(e);\r\n                    }\r\n                })\r\n            }\r\n        } else {\r\n            this.project.keysPressed[data.key] = false;\r\n        }\r\n    },\r\n    collideWidth: 0,\r\n    collideHeight: 0,\r\n    ___CHECKCOLLIDE: function (spr1, spr2) {\r\n        return false;\r\n    },\r\n    collideDiv: document.createElement(\"div\"),\r\n    addEventListener: function (name, eventName) {\r\n        this[\"on\" + name] = eventName;\r\n    },\r\n    ontick: function () {},\r\n    onspritecreate: function (sprite) {},\r\n    onstop: function () {},\r\n    __decodeDataBase64URI: function (dataURI) {\r\n        return atob(dataURI.split(\";\").pop().split(\",\").pop());\r\n    }\r\n}\r\nvm.___CHECKCOLLIDE = function isCollide(a2, b2) {\r\n    function getRealCanvasPos(x, y, width, height, canvas) {\r\n        var mainX = x - (width / 2);\r\n        var mainY = y - (height / 2);\r\n        return {\r\n            x: mainX - (canvas.width / 2),\r\n            y: mainY - (canvas.height / 2)\r\n        };\r\n    }\r\n    var a = {\r\n        width: a2.width / 2,\r\n        height: a2.height,\r\n        x: getRealCanvasPos(a2.x, a2.y, a2.width / 2, a2.height, vm.renderer.canvas).x,\r\n        y: getRealCanvasPos(a2.x, a2.y, a2.width / 2, a2.height, vm.renderer.canvas).y\r\n    };\r\n    var b = {\r\n        width: b2.width / 2,\r\n        height: b2.height,\r\n        x: getRealCanvasPos(b2.x, b2.y, b2.width / 2, b2.height, vm.renderer.canvas).x,\r\n        y: getRealCanvasPos(b2.x, b2.y, b2.width / 2, b2.height, vm.renderer.canvas).y\r\n    };\r\n    var result = (\r\n        a.x + a.width >= b.x &&\r\n        a.x <= b.x + b.width &&\r\n        a.y + a.height >= b.y &&\r\n        a.y <= b.y + b.height);\r\n    /*if (a2.image) {\r\n    document.body.appendChild(a2.image);\r\n    a2.image.style.position = 'fixed';\r\n    a2.image.style.top = a2.y+(vm.renderer.canvas.height / 2)+'px';\r\n    a2.image.style.left = a2.x+(vm.renderer.canvas.width / 2)+'px';\r\n    a2.image.width = a2.width;\r\n    a2.image.height = a2.height;\r\n    }\r\n    if (b2.image) {\r\n    document.body.appendChild(b2.image);\r\n    b2.image.style.position = 'fixed';\r\n    b2.image.style.top = b2.y+(vm.renderer.canvas.height / 2)+'px';\r\n    b2.image.style.left = b2.x+(vm.renderer.canvas.width / 2)+'px';\r\n    b2.image.width = b2.width;\r\n    b2.image.height = b2.height;\r\n    }*/\r\n    return result;\r\n};\r\nwindow.requestAnimationFrame(vm.vmTick);\r\n/*\r\nTEST SCRIPTS:\r\nwhile in devlopment I ran code to check if everything is okay and working.\r\nbasic test:\r\nvar sprite = vm.project.block.makeSprite();\r\nsprite.image = document.getElementById(\"testImage\");\r\n\r\nhide sprite test:\r\n\r\nvm.project.block.hideSprite(sprite);\r\n\r\nsecond sprite test:\r\n\r\nvar sprite2 = vm.project.block.makeSprite();\r\nsprite2.image = document.getElementById(\"testImage\");\r\n\r\nrotating sprite test:\r\nvar sprite3 = vm.project.block.makeSprite();\r\nsprite3.image = document.getElementById(\"testImage\");\r\nvm.project.events.tick.push(function () {\r\nsprite3.direction += 1;\r\n});\r\n*/\r\n"
  },
  {
   "data": "(function () {\n//ignore these variables, for the module stuff.\n    var module = {exports:null,filename:JSON.stringify(name)};\n    var require = function (a) {return gp_require(a,\"src\\\\ggm2\\\\ggm-vm\\\\renderer.js\");};\n    var var__gvbvdxx_pack_filedata = null; //prevent overwrite\n    var cur_file = \"src\\\\ggm2\\\\ggm-vm\\\\renderer.js\";\n    var console = require(\"log\");\r\n    window.renderer = {\r\n        canvas: null,\r\n        bg: document.createElement(\"img\"),\r\n        backgroundImg:null,\r\n        getUserMedia: function (a) {\r\n            return new Promise((resolve, reject) => {\r\n                navigator.getUserMedia(a, resolve, ()=>{resolve(\"CamDenied\");});\r\n            });\r\n        },\r\n        camcanvas:document.createElement(\"canvas\"),\r\n        camcontext:null,\r\n        camvid:document.createElement(\"video\"),\r\n        camrun:false,\r\n        startCameraStream: async function () {\r\n            if (!(this.camrun)) {\r\n                //not to creep out the user from thinking that they are trying to get spyed on...\r\n                var stream = await this.getUserMedia({\r\n                    video: true,\r\n                    audio: true\r\n                });\r\n                if (stream == \"CamDenied\") {\r\n                    return; //denied access (do they think that they are trying to get spyed on?)\r\n                }\r\n                //ok! we got access, so now we need to use it!\r\n                this.camstream = stream;\r\n                this.camvid.srcObject = stream;\r\n                this.camcanvas.width = this.camvid.width;\r\n                this.camcanvas.height = this.camvid.width;\r\n                this.camrun = true;\r\n                var audioContext = window.vm.audioEngine.context;\r\n                var analyser = audioContext.createAnalyser();\r\n                var microphone = audioContext.createMediaStreamSource(stream);\r\n    \r\n                analyser.smoothingTimeConstant = 0.8;\r\n                analyser.fftSize = 1024;\r\n                var rend = this;\r\n                microphone.connect(analyser);\r\n                this.caminterval = setInterval(function () {\r\n                    var array = new Uint8Array(analyser.frequencyBinCount);\r\n                    analyser.getByteFrequencyData(array);\r\n                    var arraySum = array.reduce((a, value) => a + value, 0);\r\n                    var average = arraySum / array.length;\r\n                    rend.micvol = average/200*100;\r\n                    // colorPids(average);\r\n                },1);\r\n            }\r\n        },\r\n        stopCameraStream: async function () {\r\n            //quick check to see if we are running the camrea\r\n            if (this.camrun) {\r\n                this.camrun = false; //stop rendering the camrea!\r\n                //stop recording video!\r\n                renderer.camstream.getVideoTracks().forEach((t) => {\r\n                    t.stop();\r\n                });\r\n                //stop recording audio!\r\n                renderer.camstream.getAudioTracks().forEach((t) => {\r\n                    t.stop();\r\n                });\r\n                //end video!\r\n                this.camvid.pause();\r\n                this.camvid.srcObject = null;\r\n                this.camstream = null;\r\n                clearInterval(this.caminterval);\r\n            }\r\n        },\r\n        start: function () {\r\n            this.context = this.canvas.getContext(\"2d\");\r\n            this.context.globalAlpha = 1;\r\n            this.context.strokeStyle = this.color;\r\n            this.context.fillStyle = this.color;\r\n            this.context.beginPath();\r\n            this.context.fillRect(0, 0, this.canvas.width + 2, this.canvas.height + 2);\r\n            this.context.stroke();\r\n            this.test=0;\r\n            this.canvas.style.imageRendering = \"Pixelated\";\r\n        },\r\n        camghost: 0,\r\n        tick: function (sprites,monitors) {\r\n            this.events.tick.forEach((funct) => {\r\n                try{\r\n                    funct();\r\n                }catch(e){console.error(\"renderer ran event, but an error was thrown.\",e)}\r\n            });\r\n            this.context.globalAlpha = 1;\r\n            this.context.fillStyle = this.color;\r\n            this.context.strokeStyle = this.color;\r\n            this.context.beginPath();\r\n            this.context.fillRect(0, 0, this.canvas.width + 2, this.canvas.height + 2);\r\n            this.context.stroke();\r\n            this.context.webkitImageSmoothingEnabled = false;\r\n            this.context.mozImageSmoothingEnabled = false;\r\n            this.context.imageSmoothingEnabled = false;\r\n            if (this.camrun) {\r\n                this.camcontext.globalAlpha = 1;\r\n                this.camcontext.drawImage(this.camvid,0,0,this.camcanvas.width,this.camcanvas.height);\r\n                this.context.globalAlpha = 1 - (this.camghost / 100);\r\n                this.context.drawImage(this.camvid,0,0,this.canvas.width,this.canvas.height);\r\n                this.context.globalAlpha = 1;\r\n            }\r\n            try{\r\n                this.context.drawImage(this.bg,0,0,this.canvas.width,this.canvas.height);\r\n            }catch(e){}\r\n            for (var i in sprites) {\r\n                sprites[i];\r\n                this._drawSprite(sprites[i]);\r\n            }\r\n            for (var i in monitors) {\r\n                monitors[i];\r\n                this._drawMonitor(monitors[i]);\r\n            }\r\n            this.events.ticked.forEach((funct) => {\r\n                try{\r\n                    funct();\r\n                }catch(e){console.error(\"renderer ran event, but an error was thrown.\",e)}\r\n            });\r\n        },\r\n        events:{\r\n            beforedraw:[],\r\n            afterdraw:[],\r\n            drawsprite:[],\r\n            beforemonitordraw:[],\r\n            aftermonitordraw:[],\r\n            tick:[],\r\n            ticked:[]\r\n        },\r\n        addEventListener: function (name,funct) {\r\n            if (this.events[name.toLowerCase()]) {\r\n                this.events[name.toLowerCase()].push(funct);\r\n            } else {\r\n                console.warn(\"renderer tried adding event \\\"\"+name+\"\\\" but cant find it. check the spelling and try again.\");\r\n            }\r\n        },\r\n        width:600,\r\n        height:360,\r\n        getScaleInfo: function (x,y,width,height) {\r\n            var sw = this.canvas.width/this.width;\r\n            var sh = this.canvas.height/this.height;\r\n            return {\r\n                x:Math.round(sw*x),\r\n                y:Math.round(sh*y),\r\n                w:Math.round(sw*width),\r\n                h:Math.round(sh*height),\r\n                scalewidth:sw,\r\n                scaleheight:sh\r\n            };\r\n        },\r\n        drawImage: function (img,x,y,w,h) {\r\n            var si = this.getScaleInfo(x,y,w,h);\r\n            this.context.drawImage(img,si.x,si.y,si.w,si.h);\r\n        },\r\n        translate: function (x,y) {\r\n            var si = this.getScaleInfo(x,y,0,0);\r\n            this.context.translate(si.x,si.y);\r\n        },\r\n        _drawSprite: function (json) {\r\n            this.events.beforedraw.forEach((funct) => {\r\n                try{\r\n                    funct();\r\n                }catch(e){console.error(\"renderer ran event, but an error was thrown.\",e)}\r\n            });\r\n            this.context.save();\r\n            //use the try to not throw an error when renderering failed, so the renderer keeps ticking.\r\n            try{\r\n                this.events.drawsprite.forEach((funct) => {\r\n                    try{\r\n                        funct(json);\r\n                    }catch(e){console.error(\"renderer ran event, but an error was thrown.\",e)}\r\n                });\r\n                var __calculated_x = json.x;\r\n                var __calculated_y = 0 - json.y;\r\n                var ghost = json.ghost;\r\n                if (ghost > 100) {\r\n                    ghost = 100;\r\n                }\r\n                if (ghost < 0) {\r\n                    ghost = 0;\r\n                }\r\n                this.context.globalAlpha = 1 - (ghost / 100);\r\n                //this.context.translate(this.canvas.width/2+json.x+__calculated_x, this.canvas.height/2+__calculated_y);\r\n                this.translate(this.width/2+json.x+__calculated_x, this.height/2+__calculated_y); //this moves the image to the sprite position.\r\n                this.context.rotate((json.direction - 90)*Math.PI/180);\r\n                if (json.flip == \"hor\") {\r\n                    this.context.scale(-1,1);\r\n                } else {\r\n                    if (json.flip == \"ver\") {\r\n                        this.context.scale(1,-1);\r\n                    }\r\n                }\r\n                this.drawImage(json.image, json.width/-2, json.height/-2, json.width, json.height); //draw the image and offset it so it rotates in the center.\r\n            }catch(e){}\r\n            this.context.restore();\r\n            this.events.afterdraw.forEach((funct) => {\r\n                try{\r\n                    funct();\r\n                }catch(e){console.error(\"renderer ran event, but an error was thrown.\",e)}\r\n            });\r\n        },\r\n        _drawMonitor: function (json) {\r\n            //Scale Update!!\r\n            //this also fixes some bugs when rendering vars\r\n            this.events.beforemonitordraw.forEach((funct) => {\r\n                try{\r\n                    funct();\r\n                }catch(e){console.error(\"renderer ran event, but an error was thrown.\",e)}\r\n            });\r\n            this.context.save();\r\n            //use the try to not throw an error when renderering failed, so the renderer keeps ticking.\r\n            try{\r\n                if (json.visible) {\r\n                    this.context.globalAlpha = 1;\r\n                    this.context.translate(0,0);\r\n                    var textscale = this.getScaleInfo().scalewidth;\r\n                    renderer.context.font = 'bold '+(15*this.getScaleInfo().scalewidth)+'px arial';\r\n                    var textWidth = renderer.context.measureText(json.value).width/textscale;\r\n                    var textNameWidth = renderer.context.measureText(json.name).width/textscale;\r\n                    this.context.globalAlpha = 1;\r\n                    renderer.context.fillStyle = \"#868e96\";\r\n                    renderer.fillRect(Math.round(json.x-2),Math.round(json.y-2),Math.round(24+textNameWidth+textWidth),Math.round(24));\r\n                    renderer.context.fillStyle = \"#ced4da\";\r\n                    renderer.fillRect(Math.round(json.x),Math.round(json.y),Math.round(20+textNameWidth+textWidth),Math.round(20));    \r\n                    renderer.context.fillStyle = \"#ff8c00\";\r\n                    renderer.fillRect(Math.round(json.x+textNameWidth+10),Math.round(json.y+3),Math.round(5+textWidth),Math.round(15));\r\n                    renderer.context.fillStyle = \"white\";\r\n                    renderer.fillText(json.value, Math.round(json.x+textNameWidth+12),Math.round(json.y + 16));\r\n                    renderer.context.fillStyle = \"black\";\r\n                    renderer.fillText(json.name, Math.round(json.x + 6),Math.round(json.y + 15));\r\n                    return {\r\n                        width:Math.round(74+textNameWidth+textWidth),\r\n                        height:Math.round(24),\r\n                        x:Math.round(json.x),\r\n                        y:Math.round(json.y)\r\n                    };\r\n                }\r\n            }catch(e){console.error(e);}\r\n            this.context.restore();\r\n            this.events.aftermonitordraw.forEach((funct) => {\r\n                try{\r\n                    funct();\r\n                }catch(e){console.error(\"renderer ran event, but an error was thrown.\",e)}\r\n            });\r\n        },\r\n        fillRect: function (x,y,w,h) {\r\n            var si = this.getScaleInfo(x,y,w,h);\r\n            this.context.fillRect(Math.round(si.x),Math.round(si.y),Math.round(si.w),Math.round(si.h));\r\n        },\r\n        fillText: function (txt,x,y) {\r\n            var si = this.getScaleInfo(x,y,0,0);\r\n            this.context.fillText(txt,Math.round(si.x),Math.round(si.y));\r\n        },\r\n        color:\"#ffffff\",\r\n        getColorEffect: function (img,r,g,b) {\r\n            try{\r\n                var cvs = document.createElement(\"canvas\");\r\n                var ctx = cvs.getContext(\"2d\");\r\n                cvs.width = img.width;\r\n                cvs.height = img.height;\r\n                ctx.drawImage(img,0,0,cvs.width,cvs.height);\r\n                var imgdata = ctx.getImageData(0,0,cvs.width,cvs.height);\r\n                var imageData = imgdata.data;\r\n                for (let i = 0; i < imageData.length; i += 4) {\r\n                    imageData[i] += r;\r\n                    imageData[i+1] += g;\r\n                    imageData[i+2] += g;\r\n                }\r\n                ctx.putImageData(imgdata,0,0);\r\n                return cvs.toDataURL();\r\n            }catch(e){console.error(e);}\r\n        },\r\n        getRandomColorEffect: function (img,randomness) {\r\n            try{\r\n                var cvs = document.createElement(\"canvas\");\r\n                var ctx = cvs.getContext(\"2d\");\r\n                cvs.width = img.width;\r\n                cvs.height = img.height;\r\n                ctx.drawImage(img,0,0,cvs.width,cvs.height);\r\n                var imgdata = ctx.getImageData(0,0,cvs.width,cvs.height);\r\n                var imageData = imgdata.data;\r\n                for (let i = 0; i < imageData.length; i += 4) {\r\n                    imageData[i] += Math.random()*randomness;\r\n                    imageData[i+1] += Math.random()*randomness;\r\n                    imageData[i+2] += Math.random()*randomness;\r\n                }\r\n                ctx.putImageData(imgdata,0,0);\r\n                return cvs.toDataURL();\r\n            }catch(e){console.error(e);}\r\n        },\r\n        getGlitchColorEffect: function (img,randomness) {\r\n            try{\r\n                var cvs = document.createElement(\"canvas\");\r\n                var ctx = cvs.getContext(\"2d\");\r\n                cvs.width = img.width;\r\n                cvs.height = img.height;\r\n                ctx.drawImage(img,0,0,cvs.width,cvs.height);\r\n                var imgdata = ctx.getImageData(0,0,cvs.width,cvs.height);\r\n                var imageData = imgdata.data;\r\n                for (let i = 0; i < imageData.length; i += 4) {\r\n                    imageData[i] = Math.random()*randomness;\r\n                    imageData[i+1] = Math.random()*randomness;\r\n                    imageData[i+2] = Math.random()*randomness;\r\n                }\r\n                ctx.putImageData(imgdata,0,0);\r\n                return cvs.toDataURL();\r\n            }catch(e){console.error(e);}\r\n        },\r\n        getInvertColorEffect: function (img) {\r\n            try{\r\n                var cvs = document.createElement(\"canvas\");\r\n                var ctx = cvs.getContext(\"2d\");\r\n                cvs.width = img.width;\r\n                cvs.height = img.height;\r\n                ctx.drawImage(img,0,0,cvs.width,cvs.height);\r\n                var imgdata = ctx.getImageData(0,0,cvs.width,cvs.height);\r\n                var imageData = imgdata.data;\r\n                for (let i = 0; i < imageData.length; i += 4) {\r\n                    var r = imageData[i];\r\n                    var g = imageData[i+1];\r\n                    var b = imageData[i+2];\r\n                    imageData[i] = b;\r\n                    imageData[i+1] = g;\r\n                    imageData[i+2] = r;\r\n                }\r\n                ctx.putImageData(imgdata,0,0);\r\n                return cvs.toDataURL();\r\n            }catch(e){console.error(e);}\r\n        },\r\n        getInvertColorEffect: function (img) {\r\n            try{\r\n                var cvs = document.createElement(\"canvas\");\r\n                var ctx = cvs.getContext(\"2d\");\r\n                cvs.width = img.width;\r\n                cvs.height = img.height;\r\n                ctx.drawImage(img,0,0,cvs.width,cvs.height);\r\n                var imgdata = ctx.getImageData(0,0,cvs.width,cvs.height);\r\n                var imageData = imgdata.data;\r\n                for (let i = 0; i < imageData.length; i += 4) {\r\n                    var r = imageData[i];\r\n                    var g = imageData[i+1];\r\n                    var b = imageData[i+2];\r\n                    imageData[i] = b;\r\n                    imageData[i+1] = g;\r\n                    imageData[i+2] = r;\r\n                }\r\n                ctx.putImageData(imgdata,0,0);\r\n                return cvs.toDataURL();\r\n            }catch(e){console.error(e);}\r\n        },\r\n        componentToHex:function (c) {\r\n          var hex = c.toString(16);\r\n          return hex.length == 1 ? \"0\" + hex : hex;\r\n        },\r\n        rgbToHex:function (r, g, b) {\r\n          return \"#\" + this.componentToHex(r) + this.componentToHex(g) + this.componentToHex(b);\r\n        },\r\n        hexToRgb:function (hex) {\r\n            var result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\r\n            return result ? {\r\n                r: parseInt(result[1], 16),\r\n                g: parseInt(result[2], 16),\r\n                b: parseInt(result[3], 16)\r\n            }\r\n             : null;\r\n        },\r\n        getColorAtPos: function (x,y) {\r\n            var __calculated_x = x;\r\n            var __calculated_y = 0 - y;\r\n            var pos = this.getScaleInfo(this.width/2+x+__calculated_x, this.height/2+__calculated_y,0,0);\r\n            var c = this.context.getImageData(pos.x, pos.y, 1, 1).data;\r\n            return this.rgbToHex(c[0],c[1],c[2]);\r\n        },\r\n        changeColorInImage: function (img,find,replace) {\r\n            try{\r\n                var cvs = document.createElement(\"canvas\");\r\n                var ctx = cvs.getContext(\"2d\");\r\n                cvs.width = img.width;\r\n                cvs.height = img.height;\r\n                ctx.drawImage(img,0,0,cvs.width,cvs.height);\r\n                var rgbFind = this.hexToRgb(find);\r\n                var rgbReplace = this.hexToRgb(replace);\r\n                var imgdata = ctx.getImageData(0,0,cvs.width,cvs.height);\r\n                var imageData = imgdata.data;\r\n                for (let i = 0; i < imageData.length; i += 4) {\r\n                    var r = imageData[i];\r\n                    var g = imageData[i+1];\r\n                    var b = imageData[i+2];\r\n                    if (rgbFind.r = r && rgbFind.g == g && rgbFind.b == b) {\r\n                        //found an match!\r\n                        imageData[i] = rgbReplace.r;\r\n                        imageData[i+1] = rgbReplace.g;\r\n                        imageData[i+2] = rgbReplace.b;\r\n                    }\r\n                }\r\n                ctx.putImageData(imgdata,0,0);\r\n                return cvs.toDataURL();\r\n            }catch(e){console.error(e);}\r\n        },\r\n        changeColorsInImage: function (img,findreplaceArray) {\r\n            try{\r\n                var cvs = document.createElement(\"canvas\");\r\n                var ctx = cvs.getContext(\"2d\");\r\n                cvs.width = img.width;\r\n                cvs.height = img.height;\r\n                ctx.drawImage(img,0,0,cvs.width,cvs.height);\r\n                var imgdata = ctx.getImageData(0,0,cvs.width,cvs.height);\r\n                var imageData = imgdata.data;\r\n                for (var index2 = 0; index2 < findreplaceArray.length; index2 += 2) {\r\n                    var rgbFind = this.hexToRgb(findreplaceArray[index2]);\r\n                    var rgbReplace = this.hexToRgb(findreplaceArray[index2+1]);\r\n    \r\n                    for (var i = 0; i < imageData.length; i += 4) {\r\n                        var r = imageData[i];\r\n                        var g = imageData[i+1];\r\n                        var b = imageData[i+2];\r\n                        if (rgbFind.r = r && rgbFind.g == g && rgbFind.b == b) {\r\n                            //found an match!\r\n                            imageData[i] = rgbReplace.r;\r\n                            imageData[i+1] = rgbReplace.g;\r\n                            imageData[i+2] = rgbReplace.b;\r\n                        }\r\n                    }\r\n                }\r\n    \r\n                ctx.putImageData(imgdata,0,0);\r\n                return cvs.toDataURL();\r\n            }catch(e){console.error(e);}\r\n        }\r\n    };\r\n    renderer.camcontext = renderer.camcanvas.getContext(\"2d\");\r\n    setInterval(() => {\r\n        if (renderer.camrun) {\r\n            renderer.camvid.play(); //start the recording!\r\n            renderer.camvid.volume = 0; //do not echo!\r\n            renderer.camcanvas.width = renderer.camvid.videoWidth;\r\n            renderer.camcanvas.height = renderer.camvid.videoHeight;\r\n        } else {\r\n            renderer.camvid.pause(); //stop the recording\r\n        }\r\n    },10)\r\n    \n    return module;\n})();",
   "name": "src\\ggm2\\ggm-vm\\renderer.js",
   "dirname": "src_ggm2_ggm-vm_renderer.js",
   "realdir": "src_ggm2_ggm-vm_renderer.js",
   "realdirNoReplacer": "src\\ggm2\\ggm-vm\\renderer.js",
   "uncompileddata": "var console = require(\"log\");\r\nwindow.renderer = {\r\n\tcanvas: null,\r\n\tbg: document.createElement(\"img\"),\r\n\tbackgroundImg:null,\r\n\tgetUserMedia: function (a) {\r\n\t    return new Promise((resolve, reject) => {\r\n\t        navigator.getUserMedia(a, resolve, ()=>{resolve(\"CamDenied\");});\r\n\t    });\r\n\t},\r\n\tcamcanvas:document.createElement(\"canvas\"),\r\n\tcamcontext:null,\r\n\tcamvid:document.createElement(\"video\"),\r\n\tcamrun:false,\r\n\tstartCameraStream: async function () {\r\n\t\tif (!(this.camrun)) {\r\n\t\t\t//not to creep out the user from thinking that they are trying to get spyed on...\r\n\t\t\tvar stream = await this.getUserMedia({\r\n\t\t\t\tvideo: true,\r\n\t\t\t\taudio: true\r\n\t\t\t});\r\n\t\t\tif (stream == \"CamDenied\") {\r\n\t\t\t\treturn; //denied access (do they think that they are trying to get spyed on?)\r\n\t\t\t}\r\n\t\t\t//ok! we got access, so now we need to use it!\r\n\t\t\tthis.camstream = stream;\r\n\t\t\tthis.camvid.srcObject = stream;\r\n\t\t\tthis.camcanvas.width = this.camvid.width;\r\n\t\t\tthis.camcanvas.height = this.camvid.width;\r\n\t\t\tthis.camrun = true;\r\n\t\t\tvar audioContext = window.vm.audioEngine.context;\r\n\t\t\tvar analyser = audioContext.createAnalyser();\r\n\t\t\tvar microphone = audioContext.createMediaStreamSource(stream);\r\n\r\n\t\t\tanalyser.smoothingTimeConstant = 0.8;\r\n\t\t\tanalyser.fftSize = 1024;\r\n\t\t\tvar rend = this;\r\n\t\t\tmicrophone.connect(analyser);\r\n\t\t\tthis.caminterval = setInterval(function () {\r\n\t\t\t\tvar array = new Uint8Array(analyser.frequencyBinCount);\r\n\t\t\t\tanalyser.getByteFrequencyData(array);\r\n\t\t\t\tvar arraySum = array.reduce((a, value) => a + value, 0);\r\n\t\t\t\tvar average = arraySum / array.length;\r\n\t\t\t\trend.micvol = average/200*100;\r\n\t\t\t\t// colorPids(average);\r\n\t\t\t},1);\r\n\t\t}\r\n\t},\r\n\tstopCameraStream: async function () {\r\n\t\t//quick check to see if we are running the camrea\r\n\t\tif (this.camrun) {\r\n\t\t\tthis.camrun = false; //stop rendering the camrea!\r\n\t\t\t//stop recording video!\r\n\t\t\trenderer.camstream.getVideoTracks().forEach((t) => {\r\n\t\t\t\tt.stop();\r\n\t\t\t});\r\n\t\t\t//stop recording audio!\r\n\t\t\trenderer.camstream.getAudioTracks().forEach((t) => {\r\n\t\t\t\tt.stop();\r\n\t\t\t});\r\n\t\t\t//end video!\r\n\t\t\tthis.camvid.pause();\r\n\t\t\tthis.camvid.srcObject = null;\r\n\t\t\tthis.camstream = null;\r\n\t\t\tclearInterval(this.caminterval);\r\n\t\t}\r\n\t},\r\n\tstart: function () {\r\n\t\tthis.context = this.canvas.getContext(\"2d\");\r\n\t\tthis.context.globalAlpha = 1;\r\n\t\tthis.context.strokeStyle = this.color;\r\n\t\tthis.context.fillStyle = this.color;\r\n\t\tthis.context.beginPath();\r\n\t\tthis.context.fillRect(0, 0, this.canvas.width + 2, this.canvas.height + 2);\r\n\t\tthis.context.stroke();\r\n\t\tthis.test=0;\r\n\t\tthis.canvas.style.imageRendering = \"Pixelated\";\r\n\t},\r\n\tcamghost: 0,\r\n\ttick: function (sprites,monitors) {\r\n\t\tthis.events.tick.forEach((funct) => {\r\n\t\t\ttry{\r\n\t\t\t\tfunct();\r\n\t\t\t}catch(e){console.error(\"renderer ran event, but an error was thrown.\",e)}\r\n\t\t});\r\n\t\tthis.context.globalAlpha = 1;\r\n\t\tthis.context.fillStyle = this.color;\r\n\t\tthis.context.strokeStyle = this.color;\r\n\t\tthis.context.beginPath();\r\n\t\tthis.context.fillRect(0, 0, this.canvas.width + 2, this.canvas.height + 2);\r\n\t\tthis.context.stroke();\r\n\t\tthis.context.webkitImageSmoothingEnabled = false;\r\n\t\tthis.context.mozImageSmoothingEnabled = false;\r\n\t\tthis.context.imageSmoothingEnabled = false;\r\n\t\tif (this.camrun) {\r\n\t\t\tthis.camcontext.globalAlpha = 1;\r\n\t\t\tthis.camcontext.drawImage(this.camvid,0,0,this.camcanvas.width,this.camcanvas.height);\r\n\t\t\tthis.context.globalAlpha = 1 - (this.camghost / 100);\r\n\t\t\tthis.context.drawImage(this.camvid,0,0,this.canvas.width,this.canvas.height);\r\n\t\t\tthis.context.globalAlpha = 1;\r\n\t\t}\r\n\t\ttry{\r\n\t\t\tthis.context.drawImage(this.bg,0,0,this.canvas.width,this.canvas.height);\r\n\t\t}catch(e){}\r\n\t\tfor (var i in sprites) {\r\n\t\t\tsprites[i];\r\n\t\t\tthis._drawSprite(sprites[i]);\r\n\t\t}\r\n\t\tfor (var i in monitors) {\r\n\t\t\tmonitors[i];\r\n\t\t\tthis._drawMonitor(monitors[i]);\r\n\t\t}\r\n\t\tthis.events.ticked.forEach((funct) => {\r\n\t\t\ttry{\r\n\t\t\t\tfunct();\r\n\t\t\t}catch(e){console.error(\"renderer ran event, but an error was thrown.\",e)}\r\n\t\t});\r\n\t},\r\n\tevents:{\r\n\t\tbeforedraw:[],\r\n\t\tafterdraw:[],\r\n\t\tdrawsprite:[],\r\n\t\tbeforemonitordraw:[],\r\n\t\taftermonitordraw:[],\r\n\t\ttick:[],\r\n\t\tticked:[]\r\n\t},\r\n\taddEventListener: function (name,funct) {\r\n\t\tif (this.events[name.toLowerCase()]) {\r\n\t\t\tthis.events[name.toLowerCase()].push(funct);\r\n\t\t} else {\r\n\t\t\tconsole.warn(\"renderer tried adding event \\\"\"+name+\"\\\" but cant find it. check the spelling and try again.\");\r\n\t\t}\r\n\t},\r\n\twidth:600,\r\n\theight:360,\r\n\tgetScaleInfo: function (x,y,width,height) {\r\n\t\tvar sw = this.canvas.width/this.width;\r\n\t\tvar sh = this.canvas.height/this.height;\r\n\t\treturn {\r\n\t\t\tx:Math.round(sw*x),\r\n\t\t\ty:Math.round(sh*y),\r\n\t\t\tw:Math.round(sw*width),\r\n\t\t\th:Math.round(sh*height),\r\n\t\t\tscalewidth:sw,\r\n\t\t\tscaleheight:sh\r\n\t\t};\r\n\t},\r\n\tdrawImage: function (img,x,y,w,h) {\r\n\t\tvar si = this.getScaleInfo(x,y,w,h);\r\n\t\tthis.context.drawImage(img,si.x,si.y,si.w,si.h);\r\n\t},\r\n\ttranslate: function (x,y) {\r\n\t\tvar si = this.getScaleInfo(x,y,0,0);\r\n\t\tthis.context.translate(si.x,si.y);\r\n\t},\r\n\t_drawSprite: function (json) {\r\n\t\tthis.events.beforedraw.forEach((funct) => {\r\n\t\t\ttry{\r\n\t\t\t\tfunct();\r\n\t\t\t}catch(e){console.error(\"renderer ran event, but an error was thrown.\",e)}\r\n\t\t});\r\n\t\tthis.context.save();\r\n\t\t//use the try to not throw an error when renderering failed, so the renderer keeps ticking.\r\n\t\ttry{\r\n\t\t\tthis.events.drawsprite.forEach((funct) => {\r\n\t\t\t\ttry{\r\n\t\t\t\t\tfunct(json);\r\n\t\t\t\t}catch(e){console.error(\"renderer ran event, but an error was thrown.\",e)}\r\n\t\t\t});\r\n\t\t\tvar __calculated_x = json.x;\r\n\t\t\tvar __calculated_y = 0 - json.y;\r\n\t\t\tvar ghost = json.ghost;\r\n\t\t\tif (ghost > 100) {\r\n\t\t\t\tghost = 100;\r\n\t\t\t}\r\n\t\t\tif (ghost < 0) {\r\n\t\t\t\tghost = 0;\r\n\t\t\t}\r\n\t\t\tthis.context.globalAlpha = 1 - (ghost / 100);\r\n\t\t\t//this.context.translate(this.canvas.width/2+json.x+__calculated_x, this.canvas.height/2+__calculated_y);\r\n\t\t\tthis.translate(this.width/2+json.x+__calculated_x, this.height/2+__calculated_y); //this moves the image to the sprite position.\r\n\t\t\tthis.context.rotate((json.direction - 90)*Math.PI/180);\r\n\t\t\tif (json.flip == \"hor\") {\r\n\t\t\t\tthis.context.scale(-1,1);\r\n\t\t\t} else {\r\n\t\t\t\tif (json.flip == \"ver\") {\r\n\t\t\t\t\tthis.context.scale(1,-1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.drawImage(json.image, json.width/-2, json.height/-2, json.width, json.height); //draw the image and offset it so it rotates in the center.\r\n\t\t}catch(e){}\r\n\t\tthis.context.restore();\r\n\t\tthis.events.afterdraw.forEach((funct) => {\r\n\t\t\ttry{\r\n\t\t\t\tfunct();\r\n\t\t\t}catch(e){console.error(\"renderer ran event, but an error was thrown.\",e)}\r\n\t\t});\r\n\t},\r\n\t_drawMonitor: function (json) {\r\n\t\t//Scale Update!!\r\n\t\t//this also fixes some bugs when rendering vars\r\n\t\tthis.events.beforemonitordraw.forEach((funct) => {\r\n\t\t\ttry{\r\n\t\t\t\tfunct();\r\n\t\t\t}catch(e){console.error(\"renderer ran event, but an error was thrown.\",e)}\r\n\t\t});\r\n\t\tthis.context.save();\r\n\t\t//use the try to not throw an error when renderering failed, so the renderer keeps ticking.\r\n\t\ttry{\r\n\t\t\tif (json.visible) {\r\n\t\t\t\tthis.context.globalAlpha = 1;\r\n\t\t\t\tthis.context.translate(0,0);\r\n\t\t\t\tvar textscale = this.getScaleInfo().scalewidth;\r\n\t\t\t\trenderer.context.font = 'bold '+(15*this.getScaleInfo().scalewidth)+'px arial';\r\n\t\t\t\tvar textWidth = renderer.context.measureText(json.value).width/textscale;\r\n\t\t\t\tvar textNameWidth = renderer.context.measureText(json.name).width/textscale;\r\n\t\t\t\tthis.context.globalAlpha = 1;\r\n\t\t\t\trenderer.context.fillStyle = \"#868e96\";\r\n\t\t\t\trenderer.fillRect(Math.round(json.x-2),Math.round(json.y-2),Math.round(24+textNameWidth+textWidth),Math.round(24));\r\n\t\t\t\trenderer.context.fillStyle = \"#ced4da\";\r\n\t\t\t\trenderer.fillRect(Math.round(json.x),Math.round(json.y),Math.round(20+textNameWidth+textWidth),Math.round(20));\t\r\n\t\t\t\trenderer.context.fillStyle = \"#ff8c00\";\r\n\t\t\t\trenderer.fillRect(Math.round(json.x+textNameWidth+10),Math.round(json.y+3),Math.round(5+textWidth),Math.round(15));\r\n\t\t\t\trenderer.context.fillStyle = \"white\";\r\n\t\t\t\trenderer.fillText(json.value, Math.round(json.x+textNameWidth+12),Math.round(json.y + 16));\r\n\t\t\t\trenderer.context.fillStyle = \"black\";\r\n\t\t\t\trenderer.fillText(json.name, Math.round(json.x + 6),Math.round(json.y + 15));\r\n\t\t\t\treturn {\r\n\t\t\t\t\twidth:Math.round(74+textNameWidth+textWidth),\r\n\t\t\t\t\theight:Math.round(24),\r\n\t\t\t\t\tx:Math.round(json.x),\r\n\t\t\t\t\ty:Math.round(json.y)\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t}catch(e){console.error(e);}\r\n\t\tthis.context.restore();\r\n\t\tthis.events.aftermonitordraw.forEach((funct) => {\r\n\t\t\ttry{\r\n\t\t\t\tfunct();\r\n\t\t\t}catch(e){console.error(\"renderer ran event, but an error was thrown.\",e)}\r\n\t\t});\r\n\t},\r\n\tfillRect: function (x,y,w,h) {\r\n\t\tvar si = this.getScaleInfo(x,y,w,h);\r\n\t\tthis.context.fillRect(Math.round(si.x),Math.round(si.y),Math.round(si.w),Math.round(si.h));\r\n\t},\r\n\tfillText: function (txt,x,y) {\r\n\t\tvar si = this.getScaleInfo(x,y,0,0);\r\n\t\tthis.context.fillText(txt,Math.round(si.x),Math.round(si.y));\r\n\t},\r\n\tcolor:\"#ffffff\",\r\n\tgetColorEffect: function (img,r,g,b) {\r\n\t\ttry{\r\n\t\t\tvar cvs = document.createElement(\"canvas\");\r\n\t\t\tvar ctx = cvs.getContext(\"2d\");\r\n\t\t\tcvs.width = img.width;\r\n\t\t\tcvs.height = img.height;\r\n\t\t\tctx.drawImage(img,0,0,cvs.width,cvs.height);\r\n\t\t\tvar imgdata = ctx.getImageData(0,0,cvs.width,cvs.height);\r\n\t\t\tvar imageData = imgdata.data;\r\n\t\t\tfor (let i = 0; i < imageData.length; i += 4) {\r\n\t\t\t\timageData[i] += r;\r\n\t\t\t\timageData[i+1] += g;\r\n\t\t\t\timageData[i+2] += g;\r\n\t\t\t}\r\n\t\t\tctx.putImageData(imgdata,0,0);\r\n\t\t\treturn cvs.toDataURL();\r\n\t\t}catch(e){console.error(e);}\r\n\t},\r\n\tgetRandomColorEffect: function (img,randomness) {\r\n\t\ttry{\r\n\t\t\tvar cvs = document.createElement(\"canvas\");\r\n\t\t\tvar ctx = cvs.getContext(\"2d\");\r\n\t\t\tcvs.width = img.width;\r\n\t\t\tcvs.height = img.height;\r\n\t\t\tctx.drawImage(img,0,0,cvs.width,cvs.height);\r\n\t\t\tvar imgdata = ctx.getImageData(0,0,cvs.width,cvs.height);\r\n\t\t\tvar imageData = imgdata.data;\r\n\t\t\tfor (let i = 0; i < imageData.length; i += 4) {\r\n\t\t\t\timageData[i] += Math.random()*randomness;\r\n\t\t\t\timageData[i+1] += Math.random()*randomness;\r\n\t\t\t\timageData[i+2] += Math.random()*randomness;\r\n\t\t\t}\r\n\t\t\tctx.putImageData(imgdata,0,0);\r\n\t\t\treturn cvs.toDataURL();\r\n\t\t}catch(e){console.error(e);}\r\n\t},\r\n\tgetGlitchColorEffect: function (img,randomness) {\r\n\t\ttry{\r\n\t\t\tvar cvs = document.createElement(\"canvas\");\r\n\t\t\tvar ctx = cvs.getContext(\"2d\");\r\n\t\t\tcvs.width = img.width;\r\n\t\t\tcvs.height = img.height;\r\n\t\t\tctx.drawImage(img,0,0,cvs.width,cvs.height);\r\n\t\t\tvar imgdata = ctx.getImageData(0,0,cvs.width,cvs.height);\r\n\t\t\tvar imageData = imgdata.data;\r\n\t\t\tfor (let i = 0; i < imageData.length; i += 4) {\r\n\t\t\t\timageData[i] = Math.random()*randomness;\r\n\t\t\t\timageData[i+1] = Math.random()*randomness;\r\n\t\t\t\timageData[i+2] = Math.random()*randomness;\r\n\t\t\t}\r\n\t\t\tctx.putImageData(imgdata,0,0);\r\n\t\t\treturn cvs.toDataURL();\r\n\t\t}catch(e){console.error(e);}\r\n\t},\r\n\tgetInvertColorEffect: function (img) {\r\n\t\ttry{\r\n\t\t\tvar cvs = document.createElement(\"canvas\");\r\n\t\t\tvar ctx = cvs.getContext(\"2d\");\r\n\t\t\tcvs.width = img.width;\r\n\t\t\tcvs.height = img.height;\r\n\t\t\tctx.drawImage(img,0,0,cvs.width,cvs.height);\r\n\t\t\tvar imgdata = ctx.getImageData(0,0,cvs.width,cvs.height);\r\n\t\t\tvar imageData = imgdata.data;\r\n\t\t\tfor (let i = 0; i < imageData.length; i += 4) {\r\n\t\t\t\tvar r = imageData[i];\r\n\t\t\t\tvar g = imageData[i+1];\r\n\t\t\t\tvar b = imageData[i+2];\r\n\t\t\t\timageData[i] = b;\r\n\t\t\t\timageData[i+1] = g;\r\n\t\t\t\timageData[i+2] = r;\r\n\t\t\t}\r\n\t\t\tctx.putImageData(imgdata,0,0);\r\n\t\t\treturn cvs.toDataURL();\r\n\t\t}catch(e){console.error(e);}\r\n\t},\r\n\tgetInvertColorEffect: function (img) {\r\n\t\ttry{\r\n\t\t\tvar cvs = document.createElement(\"canvas\");\r\n\t\t\tvar ctx = cvs.getContext(\"2d\");\r\n\t\t\tcvs.width = img.width;\r\n\t\t\tcvs.height = img.height;\r\n\t\t\tctx.drawImage(img,0,0,cvs.width,cvs.height);\r\n\t\t\tvar imgdata = ctx.getImageData(0,0,cvs.width,cvs.height);\r\n\t\t\tvar imageData = imgdata.data;\r\n\t\t\tfor (let i = 0; i < imageData.length; i += 4) {\r\n\t\t\t\tvar r = imageData[i];\r\n\t\t\t\tvar g = imageData[i+1];\r\n\t\t\t\tvar b = imageData[i+2];\r\n\t\t\t\timageData[i] = b;\r\n\t\t\t\timageData[i+1] = g;\r\n\t\t\t\timageData[i+2] = r;\r\n\t\t\t}\r\n\t\t\tctx.putImageData(imgdata,0,0);\r\n\t\t\treturn cvs.toDataURL();\r\n\t\t}catch(e){console.error(e);}\r\n\t},\r\n\tcomponentToHex:function (c) {\r\n\t  var hex = c.toString(16);\r\n\t  return hex.length == 1 ? \"0\" + hex : hex;\r\n\t},\r\n\trgbToHex:function (r, g, b) {\r\n\t  return \"#\" + this.componentToHex(r) + this.componentToHex(g) + this.componentToHex(b);\r\n\t},\r\n\thexToRgb:function (hex) {\r\n\t    var result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\r\n\t    return result ? {\r\n\t        r: parseInt(result[1], 16),\r\n\t        g: parseInt(result[2], 16),\r\n\t        b: parseInt(result[3], 16)\r\n\t    }\r\n\t     : null;\r\n\t},\r\n\tgetColorAtPos: function (x,y) {\r\n\t\tvar __calculated_x = x;\r\n\t\tvar __calculated_y = 0 - y;\r\n\t\tvar pos = this.getScaleInfo(this.width/2+x+__calculated_x, this.height/2+__calculated_y,0,0);\r\n\t\tvar c = this.context.getImageData(pos.x, pos.y, 1, 1).data;\r\n\t\treturn this.rgbToHex(c[0],c[1],c[2]);\r\n\t},\r\n\tchangeColorInImage: function (img,find,replace) {\r\n\t\ttry{\r\n\t\t\tvar cvs = document.createElement(\"canvas\");\r\n\t\t\tvar ctx = cvs.getContext(\"2d\");\r\n\t\t\tcvs.width = img.width;\r\n\t\t\tcvs.height = img.height;\r\n\t\t\tctx.drawImage(img,0,0,cvs.width,cvs.height);\r\n\t\t\tvar rgbFind = this.hexToRgb(find);\r\n\t\t\tvar rgbReplace = this.hexToRgb(replace);\r\n\t\t\tvar imgdata = ctx.getImageData(0,0,cvs.width,cvs.height);\r\n\t\t\tvar imageData = imgdata.data;\r\n\t\t\tfor (let i = 0; i < imageData.length; i += 4) {\r\n\t\t\t\tvar r = imageData[i];\r\n\t\t\t\tvar g = imageData[i+1];\r\n\t\t\t\tvar b = imageData[i+2];\r\n\t\t\t\tif (rgbFind.r = r && rgbFind.g == g && rgbFind.b == b) {\r\n\t\t\t\t\t//found an match!\r\n\t\t\t\t\timageData[i] = rgbReplace.r;\r\n\t\t\t\t\timageData[i+1] = rgbReplace.g;\r\n\t\t\t\t\timageData[i+2] = rgbReplace.b;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tctx.putImageData(imgdata,0,0);\r\n\t\t\treturn cvs.toDataURL();\r\n\t\t}catch(e){console.error(e);}\r\n\t},\r\n\tchangeColorsInImage: function (img,findreplaceArray) {\r\n\t\ttry{\r\n\t\t\tvar cvs = document.createElement(\"canvas\");\r\n\t\t\tvar ctx = cvs.getContext(\"2d\");\r\n\t\t\tcvs.width = img.width;\r\n\t\t\tcvs.height = img.height;\r\n\t\t\tctx.drawImage(img,0,0,cvs.width,cvs.height);\r\n\t\t\tvar imgdata = ctx.getImageData(0,0,cvs.width,cvs.height);\r\n\t\t\tvar imageData = imgdata.data;\r\n\t\t\tfor (var index2 = 0; index2 < findreplaceArray.length; index2 += 2) {\r\n\t\t\t\tvar rgbFind = this.hexToRgb(findreplaceArray[index2]);\r\n\t\t\t\tvar rgbReplace = this.hexToRgb(findreplaceArray[index2+1]);\r\n\r\n\t\t\t\tfor (var i = 0; i < imageData.length; i += 4) {\r\n\t\t\t\t\tvar r = imageData[i];\r\n\t\t\t\t\tvar g = imageData[i+1];\r\n\t\t\t\t\tvar b = imageData[i+2];\r\n\t\t\t\t\tif (rgbFind.r = r && rgbFind.g == g && rgbFind.b == b) {\r\n\t\t\t\t\t\t//found an match!\r\n\t\t\t\t\t\timageData[i] = rgbReplace.r;\r\n\t\t\t\t\t\timageData[i+1] = rgbReplace.g;\r\n\t\t\t\t\t\timageData[i+2] = rgbReplace.b;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tctx.putImageData(imgdata,0,0);\r\n\t\t\treturn cvs.toDataURL();\r\n\t\t}catch(e){console.error(e);}\r\n\t}\r\n};\r\nrenderer.camcontext = renderer.camcanvas.getContext(\"2d\");\r\nsetInterval(() => {\r\n\tif (renderer.camrun) {\r\n\t\trenderer.camvid.play(); //start the recording!\r\n\t\trenderer.camvid.volume = 0; //do not echo!\r\n\t\trenderer.camcanvas.width = renderer.camvid.videoWidth;\r\n\t\trenderer.camcanvas.height = renderer.camvid.videoHeight;\r\n\t} else {\r\n\t\trenderer.camvid.pause(); //stop the recording\r\n\t}\r\n},10)\r\n"
  },
  {
   "data": "(function () {\n//ignore these variables, for the module stuff.\n    var module = {exports:null,filename:JSON.stringify(name)};\n    var require = function (a) {return gp_require(a,\"src\\\\ggm2\\\\ggm-vm\\\\variables.js\");};\n    var var__gvbvdxx_pack_filedata = null; //prevent overwrite\n    var cur_file = \"src\\\\ggm2\\\\ggm-vm\\\\variables.js\";\n    \n    return module;\n})();",
   "name": "src\\ggm2\\ggm-vm\\variables.js",
   "dirname": "src_ggm2_ggm-vm_variables.js",
   "realdir": "src_ggm2_ggm-vm_variables.js",
   "realdirNoReplacer": "src\\ggm2\\ggm-vm\\variables.js",
   "uncompileddata": ""
  }
 ]
};/**
 * Genarated By: Gvbvdxx-Pack
 * do not copy or use this code for other programs, its only for this program,
 * do not edit or modify unless you know what your doing!
 **/


(function () {
    var dirname = "";
 var __GP_elements = {};
 var __GP_global_vars = {};
    var __gvbvdxx_pack_log = {
        log: function (a, b) {
            console.log("%c[" + a + "]:" + b, "color:black;font-weight:bold;");
        },
        warn: function (a, b) {
            console.warn("%c[" + a + "]:" + b, "color:#ffa94d;font-weight:bold;background:#d9480f;");
        },
        error: function (a, b) {
            console.error("%c[" + a + "]:" + b, "color:#ff8787;font-weight:bold;background:#c92a2a;");
        }
    };
    var gp_require = (a,filename) => {
  if (!filename) {
   throw new Error("Do NOT use gp_require, instead use require.");
  }
  if (!a) {
   throw new Error("Module must have a path to the file.");
  }
        if (a == "log") {
   //should display the modules filename now.
            return {
                log: function (b) {
     
                    console.log("%c[" + filename + "]:" + b, "color:black;font-weight:bold;");
                },
                warn: function (b) {
                    console.warn("%c[" + filename + "]:" + b, "color:#e67700;font-weight:bold;background:yellow;");
                },
                error: function (b) {
                    console.error("%c[" + filename + "]:" + b, "color:#f03e3e;font-weight:bold;background:#c92a2a;");
                }
            };
        }
  if (a == "globalvars") { //global variables across the current gvbvdxx pack program, but not available for the full window. (for better security)
   return {
    setVar:function (name,val) {
     __GP_global_vars[name] = val;
     return val;
    },
    getVar:function () {
     return __GP_global_vars[name];
    }
   };
  }
  if (a == "elements") {//Quick alternative for document access.
   return {
    appendElements: function (elm,appendArray) {
     for (var appendElm of appendArray) {
      elm.append(appendElm);
     }
    },
    createElementsFromJSON: function (jsonelmArray) { //converts an array of json's with element properties to a element list.
     function runElements(arry) {
      var myRealElms = [];
      for (var elm of arry) {
       var realElm = document.createElement(elm.element);
       for (var attriName of Object.keys(elm)) {
        if (!(
        (attriName == "element") ||
        (attriName == "children")
        )){
         var attributeValue = elm[attriName];
         var setattri = true;
         if (attriName == "gid") {
          __GP_elements[attributeValue] = realElm;
          setattri = false;
         }
         if (attriName == "style") {
          for (var styleName of Object.keys(attributeValue)) {
           var styleValue = attributeValue[styleName];
           realElm.style[styleName] = styleValue;
          }
          setattri = false;
         }
         if (attriName == "innerHTML") {
          realElm.innerHTML = attributeValue;
          setattri = false;
         }
         if (attriName == "textContent") {
          realElm.textContent = attributeValue;
          setattri = false;
         }
         if (attriName == "src") {
          realElm.src = attributeValue;
          setattri = false;
         }
         if (attriName == "value") {
          realElm.value = attributeValue;
          setattri = false;
         }
         if (attriName == "min") {
          realElm.min = attributeValue;
          setattri = false;
         }
         if (attriName == "max") {
          realElm.max = attributeValue;
          setattri = false;
         }
         if (attriName == "width") {
          realElm.width = attributeValue;
          setattri = false;
         }
         if (attriName == "height") {
          realElm.height = attributeValue;
          setattri = false;
         }
         if (attriName == "className") {
          realElm.className = attributeValue;
          setattri = false;
         }
         if (setattri) {
          realElm.setAttribute(attriName,attributeValue);
         }
        }
       }
       
       
       if (elm.children) {
        var elmsToAppend = runElements(elm.children);
        for (var elmAppend of elmsToAppend) {
         realElm.append(elmAppend);
        }
       }
       myRealElms.push(realElm);
      }
      return myRealElms;
     }
     return runElements(jsonelmArray);
    },
    getById: function (id) {
     return document.getElementById(id);
    },
    setGPId: function (el,id) {
     __GP_elements[id] = el;
     return el;
    },
    getGPId: function (id) {
     if (__GP_elements[id]) {
      return __GP_elements[id];
     }
     return null;
    },
    body:document.body
   };
  }
        if (a == "html") {
            return class HTMLEmmitter {
                constructor() {
     /*support for writing html*/
     this.writeHTML = (contents, object) => {
      var subject = null;
      if (object) {
       subject = object;
      } else {
       subject = document.body;
      }
      subject.innerHTML += contents;
      return subject;
     };
     /*support for setting html*/
     this.setHTML = (contents, object) => {
      var subject = null;
      if (object) {
       subject = object;
      } else {
       subject = document.body;
      }
      subject.innerHTML = contents;
      return subject;
     };
    }

            };
        }
        if (a == "file-loader") {
            return {
                read: function (a) {
                    for (var i in var__gvbvdxx_pack_filedata) {
                        if (var__gvbvdxx_pack_filedata[i].realdirNoReplacer.replaceAll("\\", "/") == a) {
                            return var__gvbvdxx_pack_filedata[i].uncompileddata;
                        }
                    }
                    return null;
                }
            };
        }
        for (var i in var__gvbvdxx_pack_filedata) {
            if (var__gvbvdxx_pack_filedata[i].realdirNoReplacer.replaceAll("\\", "/") == a) {
    try{
     var module = eval(var__gvbvdxx_pack_filedata[i].data);
     if (module && module.filename) {
      return module.exports;
     } else {
      __gvbvdxx_pack_log.warn("Gvbvdxx Pack", "The current module \"+"+a+"+\" is using a old exporting method, please upgrade it to \"module.exports\" and not \"return\", the module value cannot be overwitten, this module will return null.");
      return null;
     }
    } catch(e) {
     __gvbvdxx_pack_log.error("Gvbvdxx Pack", "Failed To Extucute "+var__gvbvdxx_pack_filedata[i].realdirNoReplacer+". "+e);
     throw Error(e);
     return;
    }
            }
        }
        throw Error("Unable To Find Module " + a)
    };
    var dirs = () => {
        var dirsgen = [];
        for (var i in var__gvbvdxx_pack_filedata) {
            dirsgen.push(var__gvbvdxx_pack_filedata[i].name.replaceAll("\\", "/"));
        }
        return dirsgen;
    };
    var var__gvbvdxx_pack_filedata = {};
    var__gvbvdxx_pack_filedata = GPDATA.fileTemplate;
    //__gvbvdxx_pack_log.log("Gvbvdxx Pack", "Loaded Files");
 try{
  gp_require("src/index.js","src/index.js");
 }catch(e){
  __gvbvdxx_pack_log.error("Gvbvdxx Pack", "Faild to start the program, check and make sure index.js is programmed correctly.");
 }
 delete GPDATA;
})();
